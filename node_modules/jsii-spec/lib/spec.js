"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SPEC_FILE_NAME = '.jsii';
/**
 * Versions of the JSII Assembly Specification.
 */
var SchemaVersion;
(function (SchemaVersion) {
    SchemaVersion["V1_0"] = "jsii/1.0";
})(SchemaVersion = exports.SchemaVersion || (exports.SchemaVersion = {}));
/**
 * Kinds of collections.
 */
var CollectionKind;
(function (CollectionKind) {
    CollectionKind["Array"] = "array";
    CollectionKind["Map"] = "map";
})(CollectionKind = exports.CollectionKind || (exports.CollectionKind = {}));
/**
 * Kinds of primitive types.
 */
var PrimitiveType;
(function (PrimitiveType) {
    PrimitiveType["Date"] = "date";
    PrimitiveType["String"] = "string";
    PrimitiveType["Number"] = "number";
    PrimitiveType["Boolean"] = "boolean";
    /**
     * A JSON object
     */
    PrimitiveType["Json"] = "json";
    /**
     * Value with "any" or "unknown" type (aka Object)
     */
    PrimitiveType["Any"] = "any";
})(PrimitiveType = exports.PrimitiveType || (exports.PrimitiveType = {}));
function isNamedTypeReference(ref) {
    return ref != null && !!ref.fqn;
}
exports.isNamedTypeReference = isNamedTypeReference;
function isPrimitiveTypeReference(ref) {
    return ref != null && !!ref.primitive;
}
exports.isPrimitiveTypeReference = isPrimitiveTypeReference;
function isCollectionTypeReference(ref) {
    return ref != null && !!ref.collection;
}
exports.isCollectionTypeReference = isCollectionTypeReference;
function isUnionTypeReference(ref) {
    return ref != null && !!ref.union;
}
exports.isUnionTypeReference = isUnionTypeReference;
/**
 * Kinds of types.
 */
var TypeKind;
(function (TypeKind) {
    TypeKind["Class"] = "class";
    TypeKind["Enum"] = "enum";
    TypeKind["Interface"] = "interface";
})(TypeKind = exports.TypeKind || (exports.TypeKind = {}));
function isClassType(type) {
    return type != null && type.kind === TypeKind.Class;
}
exports.isClassType = isClassType;
function isInterfaceType(type) {
    return type != null && type.kind === TypeKind.Interface;
}
exports.isInterfaceType = isInterfaceType;
function isEnumType(type) {
    return type != null && type.kind === TypeKind.Enum;
}
exports.isEnumType = isEnumType;
/**
 * Return whether this type is a class or interface type
 */
function isClassOrInterfaceType(type) {
    return isClassType(type) || isInterfaceType(type);
}
exports.isClassOrInterfaceType = isClassOrInterfaceType;
/**
 * Return a string representation of the given type reference
 */
function describeTypeReference(a) {
    if (a === undefined) {
        return '(none)';
    }
    const optionalMarker = a.optional ? '?' : '';
    if (isNamedTypeReference(a)) {
        return `${a.fqn}${optionalMarker}`;
    }
    if (isPrimitiveTypeReference(a)) {
        return `${a.primitive}${optionalMarker}`;
    }
    if (isCollectionTypeReference(a)) {
        return `${a.collection.kind}<${describeTypeReference(a.collection.elementtype)}>${optionalMarker}`;
    }
    if (isUnionTypeReference(a)) {
        const unionType = a.union.types.map(describeTypeReference).join(' | ');
        if (a.optional) {
            return `(${unionType})${optionalMarker}`;
        }
        else {
            return unionType;
        }
    }
    throw new Error('Unrecognized type reference');
}
exports.describeTypeReference = describeTypeReference;
