"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const spec = require("jsii-spec");
const os = require("os");
const path = require("path");
const tar = require("tar");
const vm = require("vm");
const api_1 = require("./api");
/**
 * Added to objects and contains the objid (the object reference).
 * Used to find the object id from an object.
 */
const OBJID_PROP = '$__jsii__objid__$';
const FQN_PROP = '$__jsii__fqn__$';
const PROXIES_PROP = '$__jsii__proxies__$';
const PROXY_REFERENT_PROP = '$__jsii__proxy_referent__$';
/**
 * A special FQN that can be used to create empty javascript objects.
 */
const EMPTY_OBJECT_FQN = 'Object';
class Kernel {
    /**
     * Creates a jsii kernel object.
     *
     * @param callbackHandler This handler is invoked when a synchronous callback is called.
     *                        It's responsibility is to execute the callback and return it's
     *                        result (or throw an error).
     */
    constructor(callbackHandler) {
        // `setImmediate` is required for tests to pass (it is otherwise
        // impossible to wait for in-VM promises to complete)
        this.callbackHandler = callbackHandler;
        /**
         * Set to true for verbose debugging.
         */
        this.traceEnabled = false;
        this.assemblies = {};
        this.objects = {};
        this.cbs = {};
        this.waiting = {};
        this.promises = {};
        this.nextid = 10000; // incrementing counter for objid, cbid, promiseid
        this.sourceMaps = {};
        // `Buffer` is required when using simple-resource-bundler.
        // HACK: when we webpack jsii-runtime, all "require" statements get transpiled,
        // so modules can be resolved within the pack. However, here we actually want to
        // let loaded modules to use the native node "require" method.
        // I wonder if webpack has some pragma that allows opting-out at certain points
        // in the code.
        const moduleLoad = require('module').Module._load;
        const nodeRequire = (p) => moduleLoad(p, module, false);
        this.sandbox = vm.createContext({
            Buffer,
            setImmediate,
            require: nodeRequire // modules need to "require"
        });
    }
    async load(req) {
        this._debug('load', req);
        if ('assembly' in req) {
            throw new Error('`assembly` field is deprecated for "load", use `name`, `version` and `tarball` instead');
        }
        if (!this.installDir) {
            this.installDir = await fs.mkdtemp(path.join(os.tmpdir(), 'jsii-kernel-'));
            await fs.mkdirp(path.join(this.installDir, 'node_modules'));
            this._debug('creating jsii-kernel modules workdir:', this.installDir);
            process.on('exit', () => {
                if (this.installDir) {
                    this._debug('removing install dir', this.installDir);
                    fs.removeSync(this.installDir); // can't use async version during exit
                }
            });
        }
        const pkgname = req.name;
        const pkgver = req.version;
        // check if we already have such a module
        const packageDir = path.join(this.installDir, 'node_modules', pkgname);
        if (await fs.pathExists(packageDir)) {
            // module exists, verify version
            const epkg = await fs.readJson(path.join(packageDir, 'package.json'));
            if (epkg.version !== pkgver) {
                throw new Error(`Multiple versions ${pkgver} and ${epkg.version} of the `
                    + `package '${pkgname}' cannot be loaded together since this is unsupported by `
                    + `some runtime environments`);
            }
            // same version, no-op
            this._debug('look up already-loaded assembly', pkgname);
            const assm = this.assemblies[pkgname];
            return {
                assembly: assm.metadata.name,
                types: Object.keys(assm.metadata.types || {}).length,
            };
        }
        else {
            // untar the archive to a staging directory, read the jsii spec from it
            // and then move it to the node_modules directory of the kernel.
            const staging = await fs.mkdtemp(path.join(os.tmpdir(), 'jsii-kernel-install-staging-'));
            try {
                await tar.extract({ strict: true, file: req.tarball, cwd: staging });
                // read .jsii metadata from the root of the package
                const jsiiMetadataFile = path.join(staging, 'package', spec.SPEC_FILE_NAME);
                if (!(await fs.pathExists(jsiiMetadataFile))) {
                    throw new Error(`Package tarball ${req.tarball} must have a file named ${spec.SPEC_FILE_NAME} at the root`);
                }
                const assmSpec = await fs.readJson(jsiiMetadataFile);
                // "install" to "node_modules" directory
                await fs.move(path.join(staging, 'package'), packageDir);
                // load the module and capture it's closure
                const closure = this._execute(`require(String.raw\`${packageDir}\`)`, packageDir);
                const assm = new Assembly(assmSpec, closure);
                this._addAssembly(assm);
                return {
                    assembly: assmSpec.name,
                    types: Object.keys(assmSpec.types || {}).length,
                };
            }
            finally {
                this._debug('removing staging directory:', staging);
                await fs.remove(staging);
            }
        }
    }
    create(req) {
        return this._create(req);
    }
    del(req) {
        const { objref } = req;
        this._debug('del', objref);
        const obj = this._findObject(objref); // make sure object exists
        delete this.objects[objref[api_1.TOKEN_REF]];
        if (obj[PROXY_REFERENT_PROP]) {
            // De-register the proxy if this was a proxy...
            delete obj[PROXY_REFERENT_PROP][PROXIES_PROP][obj[FQN_PROP]];
        }
        return {};
    }
    sget(req) {
        const { fqn, property } = req;
        const symbol = `${fqn}.${property}`;
        this._debug('sget', symbol);
        const ti = this._typeInfoForProperty(fqn, property);
        if (!ti.static) {
            throw new Error(`property ${symbol} is not static`);
        }
        const prototype = this._findSymbol(fqn);
        const value = this._ensureSync(`property ${property}`, () => this._wrapSandboxCode(() => prototype[property]));
        this._debug('value:', value);
        const ret = this._fromSandbox(value, ti.type);
        this._debug('ret', ret);
        return { value: ret };
    }
    sset(req) {
        const { fqn, property, value } = req;
        const symbol = `${fqn}.${property}`;
        this._debug('sset', symbol);
        const ti = this._typeInfoForProperty(fqn, property);
        if (!ti.static) {
            throw new Error(`property ${symbol} is not static`);
        }
        if (ti.immutable) {
            throw new Error(`static property ${symbol} is readonly`);
        }
        const prototype = this._findSymbol(fqn);
        this._ensureSync(`property ${property}`, () => this._wrapSandboxCode(() => prototype[property] = this._toSandbox(value)));
        return {};
    }
    get(req) {
        const { objref, property } = req;
        this._debug('get', objref, property);
        const obj = this._findObject(objref);
        const fqn = this._fqnForObject(obj);
        const ti = this._typeInfoForProperty(fqn, property);
        // if the property is overridden by the native code and "get" is called on the object, it
        // means that the native code is trying to access the "super" property. in order to enable
        // that, we actually keep a copy of the original property descriptor when we override,
        // so `findPropertyTarget` will return either the original property name ("property") or
        // the "super" property name (somehing like "$jsii$super$<property>$").
        const propertyToGet = this._findPropertyTarget(obj, property);
        // make the actual "get", and block any async calls that might be performed
        // by jsii overrides.
        const value = this._ensureSync(`property '${objref[api_1.TOKEN_REF]}.${propertyToGet}'`, () => this._wrapSandboxCode(() => obj[propertyToGet]));
        this._debug('value:', value);
        const ret = this._fromSandbox(value, ti.type);
        this._debug('ret:', ret);
        return { value: ret };
    }
    set(req) {
        const { objref, property, value } = req;
        this._debug('set', objref, property, value);
        const obj = this._findObject(objref);
        const fqn = this._fqnForObject(obj);
        const propInfo = this._typeInfoForProperty(fqn, req.property);
        if (propInfo.immutable) {
            throw new Error(`Cannot set value of immutable property ${req.property} to ${req.value}`);
        }
        const propertyToSet = this._findPropertyTarget(obj, property);
        this._ensureSync(`property '${objref[api_1.TOKEN_REF]}.${propertyToSet}'`, () => this._wrapSandboxCode(() => obj[propertyToSet] = this._toSandbox(value)));
        return {};
    }
    invoke(req) {
        const { objref, method } = req;
        const args = req.args || [];
        this._debug('invoke', objref, method, args);
        const { ti, obj, fn } = this._findInvokeTarget(objref, method, args);
        // verify this is not an async method
        if (ti.returns && ti.returns.promise) {
            throw new Error(`${method} is an async method, use "begin" instead`);
        }
        const ret = this._ensureSync(`method '${objref[api_1.TOKEN_REF]}.${method}'`, () => {
            return this._wrapSandboxCode(() => fn.apply(obj, this._toSandboxValues(args)));
        });
        return { result: this._fromSandbox(ret, ti.returns) };
    }
    sinvoke(req) {
        const { fqn, method } = req;
        const args = req.args || [];
        this._debug('sinvoke', fqn, method, args);
        const ti = this._typeInfoForMethod(fqn, method);
        if (!ti.static) {
            throw new Error(`${fqn}.${method} is not a static method`);
        }
        // verify this is not an async method
        if (ti.returns && ti.returns.promise) {
            throw new Error(`${method} is an async method, use "begin" instead`);
        }
        const prototype = this._findSymbol(fqn);
        const fn = prototype[method];
        const ret = this._ensureSync(`method '${fqn}.${method}'`, () => {
            return this._wrapSandboxCode(() => fn.apply(null, this._toSandboxValues(args)));
        });
        this._debug('method returned:', ret);
        return { result: this._fromSandbox(ret, ti.returns) };
    }
    begin(req) {
        const { objref, method } = req;
        const args = req.args || [];
        this._debug('begin', objref, method, args);
        if (this.syncInProgress) {
            // tslint:disable-next-line:max-line-length
            throw new Error(`Cannot invoke async method '${req.objref[api_1.TOKEN_REF]}.${req.method}' while sync ${this.syncInProgress} is being processed`);
        }
        const { ti, obj, fn } = this._findInvokeTarget(objref, method, args);
        // verify this is indeed an async method
        if (!ti.returns || !ti.returns.promise) {
            throw new Error(`Method ${method} is expected to be an async method`);
        }
        const promise = this._wrapSandboxCode(() => fn.apply(obj, this._toSandboxValues(args)));
        // since we are planning to resolve this promise in a different scope
        // we need to handle rejections here [1]
        // [1]: https://stackoverflow.com/questions/40920179/should-i-refrain-from-handling-promise-rejection-asynchronously/40921505
        promise.catch(_ => undefined);
        const prid = this._makeprid();
        this.promises[prid] = {
            promise,
            method: ti
        };
        return { promiseid: prid };
    }
    async end(req) {
        const { promiseid } = req;
        this._debug('end', promiseid);
        const { promise, method } = this.promises[promiseid];
        if (!promise) {
            throw new Error(`Cannot find promise with ID: ${promiseid}`);
        }
        let result;
        try {
            result = await promise;
            this._debug('promise result:', result);
        }
        catch (e) {
            this._debug('promise error:', e);
            throw mapSource(e, this.sourceMaps);
        }
        return { result: this._fromSandbox(result, method.returns) };
    }
    callbacks(_req) {
        this._debug('callbacks');
        const ret = Object.keys(this.cbs).map(cbid => {
            const cb = this.cbs[cbid];
            this.waiting[cbid] = cb; // move to waiting
            const callback = {
                cbid,
                cookie: cb.override.cookie,
                invoke: {
                    objref: cb.objref,
                    method: cb.override.method,
                    args: cb.args
                },
            };
            return callback;
        });
        // move all callbacks to the wait queue and clean the callback queue.
        this.cbs = {};
        return { callbacks: ret };
    }
    complete(req) {
        const { cbid, err, result } = req;
        this._debug('complete', cbid, err, result);
        if (!(cbid in this.waiting)) {
            throw new Error(`Callback ${cbid} not found`);
        }
        const cb = this.waiting[cbid];
        if (err) {
            this._debug('completed with error:', err);
            cb.fail(new Error(err));
        }
        else {
            const sandoxResult = this._toSandbox(result);
            this._debug('completed with result:', sandoxResult);
            cb.succeed(sandoxResult);
        }
        delete this.waiting[cbid];
        return { cbid };
    }
    /**
     * Returns the language-specific names for a jsii module.
     * @param assemblyName The name of the jsii module (i.e. jsii$jsii_calculator_lib$)
     */
    naming(req) {
        const assemblyName = req.assembly;
        this._debug('naming', assemblyName);
        const assembly = this._assemblyFor(assemblyName);
        const targets = assembly.metadata.targets;
        if (!targets) {
            throw new Error(`Unexpected - "targets" for ${assemblyName} is missing!`);
        }
        return { naming: targets };
    }
    stats(_req) {
        return {
            objectCount: Object.keys(this.objects).length
        };
    }
    _addAssembly(assm) {
        this.assemblies[assm.metadata.name] = assm;
        // add the __jsii__.fqn property on every constructor. this allows
        // traversing between the javascript and jsii worlds given any object.
        for (const fqn of Object.keys(assm.metadata.types || {})) {
            const typedef = assm.metadata.types[fqn];
            switch (typedef.kind) {
                case spec.TypeKind.Interface:
                    continue; // interfaces don't really exist
                case spec.TypeKind.Class:
                case spec.TypeKind.Enum:
                    const constructor = this._findSymbol(fqn);
                    constructor.__jsii__ = { fqn };
            }
        }
    }
    // find the javascript constructor function for a jsii FQN.
    _findCtor(fqn, args) {
        if (fqn === EMPTY_OBJECT_FQN) {
            return Object;
        }
        const typeinfo = this._typeInfoForFqn(fqn);
        switch (typeinfo.kind) {
            case spec.TypeKind.Class:
                const classType = typeinfo;
                this._validateMethodArguments(classType.initializer, args);
                return this._findSymbol(fqn);
            case spec.TypeKind.Interface:
                return Object;
            default:
                throw new Error(`Unexpected FQN kind: ${fqn}`);
        }
    }
    // prefixed with _ to allow calling this method internally without
    // getting it recorded for testing.
    _create(req) {
        const { fqn, overrides } = req;
        const requestArgs = req.args || [];
        const ctor = this._findCtor(fqn, requestArgs);
        const obj = this._wrapSandboxCode(() => new ctor(...this._toSandboxValues(requestArgs)));
        const objref = this._createObjref(obj, fqn);
        // overrides: for each one of the override method names, installs a
        // method on the newly created object which represents the remote "reverse proxy".
        if (overrides) {
            this._debug('overrides', overrides);
            const overrideTypeErrorMessage = 'Override can either be "method" or "property"';
            const methods = new Set();
            const properties = new Set();
            for (const override of overrides) {
                if (override.method) {
                    if (override.property) {
                        throw new Error(overrideTypeErrorMessage);
                    }
                    if (methods.has(override.method)) {
                        throw new Error(`Duplicate override for method '${override.method}'`);
                    }
                    methods.add(override.method);
                    // check that the method being overridden actually exists
                    let methodInfo;
                    if (fqn !== EMPTY_OBJECT_FQN) {
                        // error if we can find a property with this name
                        if (this._tryTypeInfoForProperty(fqn, override.method)) {
                            throw new Error(`Trying to override property '${override.method}' as a method`);
                        }
                        methodInfo = this._tryTypeInfoForMethod(fqn, override.method);
                    }
                    this._applyMethodOverride(obj, objref, override, methodInfo);
                }
                else if (override.property) {
                    if (override.method) {
                        throw new Error(overrideTypeErrorMessage);
                    }
                    if (properties.has(override.property)) {
                        throw Error(`Duplicate override for property '${override.property}'`);
                    }
                    properties.add(override.property);
                    let propInfo;
                    if (fqn !== EMPTY_OBJECT_FQN) {
                        // error if we can find a method with this name
                        if (this._tryTypeInfoForMethod(fqn, override.property)) {
                            throw new Error(`Trying to override method '${override.property}' as a property`);
                        }
                        propInfo = this._tryTypeInfoForProperty(fqn, override.property);
                    }
                    this._applyPropertyOverride(obj, objref, override, propInfo);
                }
                else {
                    throw new Error(overrideTypeErrorMessage);
                }
            }
        }
        return objref;
    }
    _getSuperPropertyName(name) {
        return `$jsii$super$${name}$`;
    }
    _applyPropertyOverride(obj, objref, override, propInfo) {
        const self = this;
        const propertyName = override.property;
        // if this is a private property (i.e. doesn't have `propInfo` the object has a key)
        if (!propInfo && propertyName in obj) {
            this._debug(`Skipping override of private property ${propertyName}`);
            return;
        }
        this._debug('apply override', propertyName);
        // save the old property under $jsii$super$<prop>$ so that property overrides
        // can still access it via `super.<prop>`.
        const prev = Object.getOwnPropertyDescriptor(obj, propertyName) || {
            value: undefined,
            writable: true,
            enumerable: true,
            configurable: true
        };
        const prevEnumerable = prev.enumerable;
        prev.enumerable = false;
        Object.defineProperty(obj, this._getSuperPropertyName(propertyName), prev);
        // we add callbacks for both 'get' and 'set', even if the property
        // is readonly. this is fine because if you try to set() a readonly
        // property, it will fail.
        Object.defineProperty(obj, propertyName, {
            enumerable: prevEnumerable,
            configurable: prev.configurable,
            get: () => {
                const result = self.callbackHandler({
                    cookie: override.cookie,
                    cbid: self._makecbid(),
                    get: { objref, property: propertyName }
                });
                this._debug('callback returned', result);
                return this._toSandbox(result);
            },
            set: (value) => {
                self._debug('virtual set', objref, propertyName, { cookie: override.cookie });
                self.callbackHandler({
                    cookie: override.cookie,
                    cbid: self._makecbid(),
                    set: { objref, property: propertyName, value: self._fromSandbox(value) }
                });
            }
        });
    }
    _applyMethodOverride(obj, objref, override, methodInfo) {
        const self = this;
        const methodName = override.method;
        // If this is a private method (doesn't have methodInfo, key resolves on the object), we
        // are going to skip the override.
        if (!methodInfo && obj[methodName]) {
            this._debug(`Skipping override of private method ${methodName}`);
            return;
        }
        // note that we are applying the override even if the method doesn't exist
        // on the type spec in order to allow native code to override methods from
        // interfaces.
        if (methodInfo && methodInfo.returns && methodInfo.returns.promise) {
            // async method override
            Object.defineProperty(obj, methodName, {
                enumerable: false,
                configurable: false,
                writable: false,
                value: (...methodArgs) => {
                    self._debug('invoked async override', override);
                    const args = self._toSandboxValues(methodArgs);
                    return new Promise((succeed, fail) => {
                        const cbid = self._makecbid();
                        self._debug('adding callback to queue', cbid);
                        self.cbs[cbid] = {
                            objref,
                            override,
                            args,
                            succeed,
                            fail
                        };
                    });
                }
            });
        }
        else {
            // sync method override (method info is not required)
            Object.defineProperty(obj, methodName, {
                enumerable: false,
                configurable: false,
                writable: false,
                value: (...methodArgs) => {
                    const result = self.callbackHandler({
                        cookie: override.cookie,
                        cbid: self._makecbid(),
                        invoke: {
                            objref,
                            method: methodName,
                            args: this._fromSandbox(methodArgs)
                        }
                    });
                    return this._toSandbox(result);
                }
            });
        }
    }
    _findInvokeTarget(objref, methodName, args) {
        const obj = this._findObject(objref);
        const fqn = this._fqnForObject(obj);
        const ti = this._typeInfoForMethod(fqn, methodName);
        this._validateMethodArguments(ti, args);
        // always first look up the method in the prototype. this practically bypasses
        // any methods overridden by derived classes (which are by definition native
        // methods). this serves to allow native call to invoke "super.method()" when
        // overriding the method.
        // if we didn't find the method on the prototype, it could be a literal object
        // that implements an interface, so we look if we have the method on the object
        // itself. if we do, we invoke it.
        let fn = obj.constructor.prototype[methodName];
        if (!fn) {
            fn = obj[methodName];
            if (!fn) {
                throw new Error(`Cannot find ${methodName} on object`);
            }
        }
        return { ti, obj, fn };
    }
    _formatTypeRef(typeRef) {
        if (spec.isCollectionTypeReference(typeRef)) {
            return `${typeRef.collection.kind}<${this._formatTypeRef(typeRef.collection.elementtype)}>`;
        }
        if (spec.isNamedTypeReference(typeRef)) {
            return typeRef.fqn;
        }
        if (spec.isPrimitiveTypeReference(typeRef)) {
            return typeRef.primitive;
        }
        if (spec.isUnionTypeReference(typeRef)) {
            return typeRef.union.types.map(t => this._formatTypeRef(t)).join(' | ');
        }
        throw new Error(`Invalid type reference: ${JSON.stringify(typeRef)}`);
    }
    _validateMethodArguments(method, args) {
        const params = (method && method.parameters) || [];
        // error if args > params
        if (args.length > params.length && !(method && method.variadic)) {
            throw new Error(`Too many arguments (method accepts ${params.length} parameters, got ${args.length} arguments)`);
        }
        for (let i = 0; i < params.length; ++i) {
            const param = params[i];
            const arg = args[i];
            if (param.variadic) {
                if (params.length <= i) {
                    return;
                } // No vararg was provided
                for (let j = i; j < params.length; j++) {
                    if (params[j] === undefined) {
                        // tslint:disable-next-line:max-line-length
                        throw new Error(`Unexpected 'undefined' value at index ${j - i} of variadic argument '${param.name}' of type '${this._formatTypeRef(param.type)}'`);
                    }
                }
            }
            else if (!param.type.optional && arg === undefined) {
                // tslint:disable-next-line:max-line-length
                throw new Error(`Not enough arguments. Missing argument for the required parameter '${param.name}' of type '${this._formatTypeRef(param.type)}'`);
            }
        }
    }
    _assemblyFor(assemblyName) {
        const assembly = this.assemblies[assemblyName];
        if (!assembly) {
            throw new Error(`Could not find assembly: ${assemblyName}`);
        }
        return assembly;
    }
    _findSymbol(fqn) {
        const [assemblyName, ...parts] = fqn.split('.');
        const assembly = this._assemblyFor(assemblyName);
        let curr = assembly.closure;
        while (true) {
            const name = parts.shift();
            if (!name) {
                break;
            }
            curr = curr[name];
        }
        if (!curr) {
            throw new Error(`Could not find symbol ${fqn}`);
        }
        return curr;
    }
    _createObjref(obj, fqn) {
        const objid = this._mkobjid(fqn);
        Object.defineProperty(obj, OBJID_PROP, {
            value: objid,
            configurable: false,
            enumerable: false,
            writable: false
        });
        Object.defineProperty(obj, FQN_PROP, {
            value: fqn,
            configurable: false,
            enumerable: false,
            writable: false
        });
        this.objects[objid] = obj;
        return { [api_1.TOKEN_REF]: objid };
    }
    _findObject(objref) {
        if (typeof (objref) !== 'object' || !(api_1.TOKEN_REF in objref)) {
            throw new Error(`Malformed object reference: ${JSON.stringify(objref)}`);
        }
        const objid = objref[api_1.TOKEN_REF];
        this._debug('findObject', objid);
        const obj = this.objects[objid];
        if (!obj) {
            throw new Error(`Object ${objid} not found`);
        }
        return obj;
    }
    _typeInfoForFqn(fqn) {
        const components = fqn.split('.');
        const moduleName = components[0];
        const assembly = this.assemblies[moduleName];
        if (!assembly) {
            throw new Error(`Module '${moduleName}' not found`);
        }
        const types = assembly.metadata.types || {};
        const fqnInfo = types[fqn];
        if (!fqnInfo) {
            throw new Error(`Type '${fqn}' not found`);
        }
        return fqnInfo;
    }
    _typeInfoForMethod(fqn, methodName) {
        const ti = this._tryTypeInfoForMethod(fqn, methodName);
        if (!ti) {
            throw new Error(`Class ${fqn} doesn't have a method '${methodName}'`);
        }
        return ti;
    }
    _tryTypeInfoForMethod(fqn, methodName) {
        const typeinfo = this._typeInfoForFqn(fqn);
        const methods = typeinfo.methods || [];
        const bases = [
            typeinfo.base,
            ...(typeinfo.interfaces || [])
        ];
        for (const m of methods) {
            if (m.name === methodName) {
                return m;
            }
        }
        // recursion to parent type (if exists)
        for (const base of bases) {
            if (!base) {
                continue;
            }
            const found = this._tryTypeInfoForMethod(base.fqn, methodName);
            if (found) {
                return found;
            }
        }
        return undefined;
    }
    _tryTypeInfoForProperty(fqn, property) {
        if (!fqn) {
            throw new Error('missing "fqn"');
        }
        const typeInfo = this._typeInfoForFqn(fqn);
        let properties;
        let bases;
        if (spec.isClassType(typeInfo)) {
            const classTypeInfo = typeInfo;
            properties = classTypeInfo.properties;
            bases = classTypeInfo.base ? [classTypeInfo.base.fqn] : [];
        }
        else if (spec.isInterfaceType(typeInfo)) {
            const interfaceTypeInfo = typeInfo;
            properties = interfaceTypeInfo.properties;
            bases = (interfaceTypeInfo.interfaces || []).map(x => x.fqn);
        }
        else {
            throw new Error(`Type of kind ${typeInfo.kind} does not have properties`);
        }
        for (const p of properties || []) {
            if (p.name === property) {
                return p;
            }
        }
        // recurse to parent type (if exists)
        for (const baseFqn of bases) {
            const ret = this._tryTypeInfoForProperty(baseFqn, property);
            if (ret) {
                return ret;
            }
        }
        return undefined;
    }
    _typeInfoForProperty(fqn, property) {
        const typeInfo = this._tryTypeInfoForProperty(fqn, property);
        if (!typeInfo) {
            throw new Error(`Type ${fqn} doesn't have a property '${property}'`);
        }
        return typeInfo;
    }
    _toSandbox(v) {
        // undefined
        if (typeof v === 'undefined') {
            return undefined;
        }
        // null is treated as "undefined" because most languages do not have this distinction
        // see awslabs/aws-cdk#157 and awslabs/jsii#282
        if (v === null) {
            return undefined;
        }
        // pointer
        if (typeof v === 'object' && api_1.TOKEN_REF in v) {
            return this._findObject(v);
        }
        // date
        if (typeof v === 'object' && api_1.TOKEN_DATE in v) {
            this._debug('Found date:', v);
            return new Date(v[api_1.TOKEN_DATE]);
        }
        // enums
        if (typeof v === 'object' && api_1.TOKEN_ENUM in v) {
            this._debug('Enum:', v);
            const value = v[api_1.TOKEN_ENUM];
            const sep = value.lastIndexOf('/');
            if (sep === -1) {
                throw new Error(`Malformed enum value: ${v[api_1.TOKEN_ENUM]}`);
            }
            const typeName = value.substr(0, sep);
            const valueName = value.substr(sep + 1);
            const enumValue = this._findSymbol(typeName)[valueName];
            if (enumValue === undefined) {
                throw new Error(`No enum member named ${valueName} in ${typeName}`);
            }
            this._debug('resolved enum value:', enumValue);
            return enumValue;
        }
        // array
        if (Array.isArray(v)) {
            return v.map(x => this._toSandbox(x));
        }
        // map
        if (typeof v === 'object') {
            const out = {};
            for (const k of Object.keys(v)) {
                out[k] = this._toSandbox(v[k]);
            }
            return out;
        }
        // primitive
        return v;
    }
    _fromSandbox(v, targetType) {
        this._debug('fromSandbox', v, targetType);
        // undefined is returned as null: true
        if (typeof (v) === 'undefined') {
            return undefined;
        }
        // existing object
        const objid = v[OBJID_PROP];
        if (objid) {
            // object already has an objid, return it as a ref.
            this._debug('objref exists', objid);
            return { [api_1.TOKEN_REF]: objid };
        }
        // new object
        if (typeof (v) === 'object' && v.constructor.__jsii__) {
            // this is jsii object which was created inside the sandbox and still doesn't
            // have an object id, so we need to allocate one for it.
            this._debug('creating objref for', v);
            const fqn = this._fqnForObject(v);
            return this._createObjref(v, fqn);
        }
        // if the method/property returns an object literal and the return type
        // is a class, we create a new object based on the fqn and assign all keys.
        // so the client receives a real object.
        if (typeof (v) === 'object' && targetType && spec.isNamedTypeReference(targetType)) {
            this._debug('coalescing to', targetType);
            /*
             * We "cache" proxy instances in [PROXIES_PROP] so we can return an
             * identical object reference upon multiple accesses of the same
             * object literal under the same exposed type. This results in a
             * behavior that is more consistent with class instances.
             */
            const proxies = v[PROXIES_PROP] = v[PROXIES_PROP] || {};
            if (!proxies[targetType.fqn]) {
                const handler = new KernelProxyHandler(v);
                const proxy = new Proxy(v, handler);
                // _createObjref will set the FQN_PROP & OBJID_PROP on the proxy.
                proxies[targetType.fqn] = { objRef: this._createObjref(proxy, targetType.fqn), handler };
            }
            return proxies[targetType.fqn].objRef;
        }
        // date (https://stackoverflow.com/a/643827/737957)
        if (typeof (v) === 'object' && Object.prototype.toString.call(v) === '[object Date]') {
            this._debug('date', v);
            return { [api_1.TOKEN_DATE]: v.toISOString() };
        }
        // array
        if (Array.isArray(v)) {
            this._debug('array', v);
            return v.map(x => this._fromSandbox(x));
        }
        if (targetType && spec.isNamedTypeReference(targetType)) {
            const propType = this._typeInfoForFqn(targetType.fqn);
            // enum
            if (propType.kind === spec.TypeKind.Enum) {
                this._debug('enum', v);
                const fqn = propType.fqn;
                const valueName = this._findSymbol(fqn)[v];
                return { [api_1.TOKEN_ENUM]: `${propType.fqn}/${valueName}` };
            }
        }
        // map
        if (typeof (v) === 'object') {
            this._debug('map', v);
            const out = {};
            for (const k of Object.keys(v)) {
                out[k] = this._fromSandbox(v[k]);
            }
            return out;
        }
        // primitive
        this._debug('primitive', v);
        return v;
    }
    _toSandboxValues(args) {
        return args.map(v => this._toSandbox(v));
    }
    _debug(...args) {
        if (this.traceEnabled) {
            // tslint:disable-next-line:no-console
            console.error.apply(console, [
                '[jsii-kernel]',
                args[0],
                ...args.slice(1)
            ]);
        }
    }
    /**
     * Ensures that `fn` is called and defends against beginning to invoke
     * async methods until fn finishes (successfully or not).
     */
    _ensureSync(desc, fn) {
        this.syncInProgress = desc;
        try {
            return fn();
        }
        catch (e) {
            throw e;
        }
        finally {
            delete this.syncInProgress;
        }
    }
    _findPropertyTarget(obj, property) {
        const superProp = this._getSuperPropertyName(property);
        if (superProp in obj) {
            return superProp;
        }
        else {
            return property;
        }
    }
    //
    // type information
    //
    _fqnForObject(obj) {
        if (FQN_PROP in obj) {
            return obj[FQN_PROP];
        }
        if (!obj.constructor.__jsii__) {
            throw new Error('No jsii type info for object');
        }
        return obj.constructor.__jsii__.fqn;
    }
    _mkobjid(fqn) {
        return `${fqn}@${this.nextid++}`;
    }
    _makecbid() {
        return `jsii::callback::${this.nextid++}`;
    }
    _makeprid() {
        return `jsii::promise::${this.nextid++}`;
    }
    _wrapSandboxCode(fn) {
        try {
            return fn();
        }
        catch (err) {
            throw mapSource(err, this.sourceMaps);
        }
    }
    /**
     * Executes arbitrary code in a VM sandbox.
     *
     * @param code       JavaScript code to be executed in the VM
     * @param sandbox    a VM context to use for running the code
     * @param sourceMaps source maps to be used in case an exception is thrown
     * @param filename   the file name to use for the executed code
     *
     * @returns the result of evaluating the code
     */
    _execute(code, filename) {
        const script = new vm.Script(code, { filename });
        try {
            return script.runInContext(this.sandbox, { displayErrors: true });
        }
        catch (err) {
            throw mapSource(err, this.sourceMaps);
        }
    }
}
exports.Kernel = Kernel;
class Assembly {
    constructor(metadata, closure) {
        this.metadata = metadata;
        this.closure = closure;
    }
}
/**
 * Applies source maps to an error's stack trace and returns the mapped error,
 * and stitches stack trace elements to adapt the context to the current trace.
 *
 * @param err        is the error to be mapped
 * @param sourceMaps the source maps to be used
 *
 * @returns the mapped error
 */
function mapSource(err, sourceMaps) {
    if (!err.stack) {
        return err;
    }
    const oldFrames = err.stack.split("\n");
    const obj = { stack: '' };
    const previousLimit = Error.stackTraceLimit;
    try {
        Error.stackTraceLimit = err.stack.split("\n").length;
        Error.captureStackTrace(obj, mapSource);
        const realFrames = obj.stack.split('\n').slice(1);
        const topFrame = realFrames[0].substring(0, realFrames[0].indexOf(' ('));
        err.stack = [
            ...oldFrames.slice(0, oldFrames.findIndex(frame => frame.startsWith(topFrame))).map(applyMaps),
            ...realFrames
        ].join("\n");
        return err;
    }
    finally {
        Error.stackTraceLimit = previousLimit;
    }
    function applyMaps(frame) {
        const mappable = /^(\s*at\s+.+)\(jsii\/(.+)\.js:(\d+):(\d+)\)$/;
        const matches = mappable.exec(frame);
        if (!matches) {
            return frame;
        }
        const assm = matches[2];
        if (!(assm in sourceMaps)) {
            return frame;
        }
        const prefix = matches[1];
        const line = parseInt(matches[3], 10);
        const column = parseInt(matches[4], 10);
        const sourceMap = sourceMaps[assm];
        const pos = sourceMap.originalPositionFor({ line, column });
        if (pos.source != null && pos.line != null) {
            const source = pos.source.replace(/^webpack:\/\//, `${assm}`);
            return `${prefix}(${source}:${pos.line}:${pos.column || 0})`;
        }
        return frame;
    }
}
/**
 * A Proxy handler class to support mutation of the returned object literals, as
 * they may "embody" several different interfaces. The handler is in particular
 * responsible to make sure the ``FQN_PROP`` and ``OBJID_PROP`` do not get set
 * on the ``referent`` object, for this would cause subsequent accesses to
 * possibly return incorrect object references.
 */
class KernelProxyHandler {
    /**
     * @param referent the "real" value that will be returned.
     */
    constructor(referent) {
        this.referent = referent;
        this.ownProperties = {};
        /*
         * Proxy-properties must exist as non-configurable & writable on the
         * referent, otherwise the Proxy will not allow returning ``true`` in
         * response to ``defineProperty``.
         */
        for (const prop of [FQN_PROP, OBJID_PROP]) {
            Object.defineProperty(referent, prop, {
                configurable: false,
                enumerable: false,
                writable: true,
                value: undefined
            });
        }
    }
    defineProperty(target, property, attributes) {
        switch (property) {
            case FQN_PROP:
            case OBJID_PROP:
                return Object.defineProperty(this.ownProperties, property, attributes);
            default:
                return Object.defineProperty(target, property, attributes);
        }
    }
    deleteProperty(target, property) {
        switch (property) {
            case FQN_PROP:
            case OBJID_PROP:
                delete this.ownProperties[property];
                break;
            default:
                delete target[property];
        }
        return true;
    }
    getOwnPropertyDescriptor(target, property) {
        switch (property) {
            case FQN_PROP:
            case OBJID_PROP:
                return Object.getOwnPropertyDescriptor(this.ownProperties, property);
            default:
                return Object.getOwnPropertyDescriptor(target, property);
        }
    }
    get(target, property) {
        switch (property) {
            // Magical property for the proxy, so we can tell it's one...
            case PROXY_REFERENT_PROP:
                return this.referent;
            case FQN_PROP:
            case OBJID_PROP:
                return this.ownProperties[property];
            default:
                return target[property];
        }
    }
    set(target, property, value) {
        switch (property) {
            case FQN_PROP:
            case OBJID_PROP:
                this.ownProperties[property] = value;
                break;
            default:
                target[property] = value;
        }
        return true;
    }
    has(target, property) {
        switch (property) {
            case FQN_PROP:
            case OBJID_PROP:
                return property in this.ownProperties;
            default:
                return property in target;
        }
    }
    ownKeys(target) {
        return Reflect.ownKeys(target).concat(Reflect.ownKeys(this.ownProperties));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoia2VybmVsLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsia2VybmVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsK0JBQStCO0FBQy9CLGtDQUFrQztBQUNsQyx5QkFBeUI7QUFDekIsNkJBQTZCO0FBRTdCLDJCQUEyQjtBQUMzQix5QkFBeUI7QUFFekIsK0JBQTBEO0FBRTFEOzs7R0FHRztBQUNILE1BQU0sVUFBVSxHQUFHLG1CQUFtQixDQUFDO0FBQ3ZDLE1BQU0sUUFBUSxHQUFHLGlCQUFpQixDQUFDO0FBQ25DLE1BQU0sWUFBWSxHQUFHLHFCQUFxQixDQUFDO0FBQzNDLE1BQU0sbUJBQW1CLEdBQUcsNEJBQTRCLENBQUM7QUFFekQ7O0dBRUc7QUFDSCxNQUFNLGdCQUFnQixHQUFHLFFBQVEsQ0FBQztBQUVsQyxNQUFhLE1BQU07SUFrQmY7Ozs7OztPQU1HO0lBQ0gsWUFBbUIsZUFBZ0Q7UUFDL0QsZ0VBQWdFO1FBQ2hFLHFEQUFxRDtRQUZ0QyxvQkFBZSxHQUFmLGVBQWUsQ0FBaUM7UUF4Qm5FOztXQUVHO1FBQ0ksaUJBQVksR0FBRyxLQUFLLENBQUM7UUFFcEIsZUFBVSxHQUFpQyxFQUFHLENBQUM7UUFDL0MsWUFBTyxHQUE2QixFQUFHLENBQUM7UUFDeEMsUUFBRyxHQUFpQyxFQUFHLENBQUM7UUFDeEMsWUFBTyxHQUFpQyxFQUFHLENBQUM7UUFDNUMsYUFBUSxHQUF3QyxFQUFHLENBQUM7UUFDcEQsV0FBTSxHQUFHLEtBQUssQ0FBQyxDQUFDLGtEQUFrRDtRQUt6RCxlQUFVLEdBQTBDLEVBQUUsQ0FBQztRQWFwRSwyREFBMkQ7UUFFM0QsK0VBQStFO1FBQy9FLGdGQUFnRjtRQUNoRiw4REFBOEQ7UUFDOUQsK0VBQStFO1FBQy9FLGVBQWU7UUFDZixNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztRQUNsRCxNQUFNLFdBQVcsR0FBRyxDQUFDLENBQVMsRUFBRSxFQUFF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bSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgc3BlYyBmcm9tICdqc2lpLXNwZWMnO1xuaW1wb3J0ICogYXMgb3MgZnJvbSAnb3MnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IFNvdXJjZU1hcENvbnN1bWVyIH0gZnJvbSAnc291cmNlLW1hcCc7XG5pbXBvcnQgKiBhcyB0YXIgZnJvbSAndGFyJztcbmltcG9ydCAqIGFzIHZtIGZyb20gJ3ZtJztcbmltcG9ydCAqIGFzIGFwaSBmcm9tICcuL2FwaSc7XG5pbXBvcnQgeyBUT0tFTl9EQVRFLCBUT0tFTl9FTlVNLCBUT0tFTl9SRUYgfSBmcm9tICcuL2FwaSc7XG5cbi8qKlxuICogQWRkZWQgdG8gb2JqZWN0cyBhbmQgY29udGFpbnMgdGhlIG9iamlkICh0aGUgb2JqZWN0IHJlZmVyZW5jZSkuXG4gKiBVc2VkIHRvIGZpbmQgdGhlIG9iamVjdCBpZCBmcm9tIGFuIG9iamVjdC5cbiAqL1xuY29uc3QgT0JKSURfUFJPUCA9ICckX19qc2lpX19vYmppZF9fJCc7XG5jb25zdCBGUU5fUFJPUCA9ICckX19qc2lpX19mcW5fXyQnO1xuY29uc3QgUFJPWElFU19QUk9QID0gJyRfX2pzaWlfX3Byb3hpZXNfXyQnO1xuY29uc3QgUFJPWFlfUkVGRVJFTlRfUFJPUCA9ICckX19qc2lpX19wcm94eV9yZWZlcmVudF9fJCc7XG5cbi8qKlxuICogQSBzcGVjaWFsIEZRTiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBlbXB0eSBqYXZhc2NyaXB0IG9iamVjdHMuXG4gKi9cbmNvbnN0IEVNUFRZX09CSkVDVF9GUU4gPSAnT2JqZWN0JztcblxuZXhwb3J0IGNsYXNzIEtlcm5lbCB7XG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgZm9yIHZlcmJvc2UgZGVidWdnaW5nLlxuICAgICAqL1xuICAgIHB1YmxpYyB0cmFjZUVuYWJsZWQgPSBmYWxzZTtcblxuICAgIHByaXZhdGUgYXNzZW1ibGllczogeyBbbmFtZTogc3RyaW5nXTogQXNzZW1ibHkgfSA9IHsgfTtcbiAgICBwcml2YXRlIG9iamVjdHM6IHsgW29iamlkOiBzdHJpbmddOiBhbnkgfSA9IHsgfTtcbiAgICBwcml2YXRlIGNiczogeyBbY2JpZDogc3RyaW5nXTogQ2FsbGJhY2sgfSA9IHsgfTtcbiAgICBwcml2YXRlIHdhaXRpbmc6IHsgW2NiaWQ6IHN0cmluZ106IENhbGxiYWNrIH0gPSB7IH07XG4gICAgcHJpdmF0ZSBwcm9taXNlczogeyBbcHJpZDogc3RyaW5nXTogQXN5bmNJbnZvY2F0aW9uIH0gPSB7IH07XG4gICAgcHJpdmF0ZSBuZXh0aWQgPSAxMDAwMDsgLy8gaW5jcmVtZW50aW5nIGNvdW50ZXIgZm9yIG9iamlkLCBjYmlkLCBwcm9taXNlaWRcbiAgICBwcml2YXRlIHN5bmNJblByb2dyZXNzPzogc3RyaW5nOyAvLyBmb3JiaWRzIGFzeW5jIGNhbGxzIChiZWdpbikgd2hpbGUgcHJvY2Vzc2luZyBzeW5jIGNhbGxzIChnZXQvc2V0L2ludm9rZSlcbiAgICBwcml2YXRlIGluc3RhbGxEaXI/OiBzdHJpbmc7XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IHNhbmRib3g6IHZtLkNvbnRleHQ7XG4gICAgcHJpdmF0ZSByZWFkb25seSBzb3VyY2VNYXBzOiB7IFthc3NtOiBzdHJpbmddOiBTb3VyY2VNYXBDb25zdW1lciB9ID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEganNpaSBrZXJuZWwgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrSGFuZGxlciBUaGlzIGhhbmRsZXIgaXMgaW52b2tlZCB3aGVuIGEgc3luY2hyb25vdXMgY2FsbGJhY2sgaXMgY2FsbGVkLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgSXQncyByZXNwb25zaWJpbGl0eSBpcyB0byBleGVjdXRlIHRoZSBjYWxsYmFjayBhbmQgcmV0dXJuIGl0J3NcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCAob3IgdGhyb3cgYW4gZXJyb3IpLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBjYWxsYmFja0hhbmRsZXI6IChjYWxsYmFjazogYXBpLkNhbGxiYWNrKSA9PiBhbnkpIHtcbiAgICAgICAgLy8gYHNldEltbWVkaWF0ZWAgaXMgcmVxdWlyZWQgZm9yIHRlc3RzIHRvIHBhc3MgKGl0IGlzIG90aGVyd2lzZVxuICAgICAgICAvLyBpbXBvc3NpYmxlIHRvIHdhaXQgZm9yIGluLVZNIHByb21pc2VzIHRvIGNvbXBsZXRlKVxuXG4gICAgICAgIC8vIGBCdWZmZXJgIGlzIHJlcXVpcmVkIHdoZW4gdXNpbmcgc2ltcGxlLXJlc291cmNlLWJ1bmRsZXIuXG5cbiAgICAgICAgLy8gSEFDSzogd2hlbiB3ZSB3ZWJwYWNrIGpzaWktcnVudGltZSwgYWxsIFwicmVxdWlyZVwiIHN0YXRlbWVudHMgZ2V0IHRyYW5zcGlsZWQsXG4gICAgICAgIC8vIHNvIG1vZHVsZXMgY2FuIGJlIHJlc29sdmVkIHdpdGhpbiB0aGUgcGFjay4gSG93ZXZlciwgaGVyZSB3ZSBhY3R1YWxseSB3YW50IHRvXG4gICAgICAgIC8vIGxldCBsb2FkZWQgbW9kdWxlcyB0byB1c2UgdGhlIG5hdGl2ZSBub2RlIFwicmVxdWlyZVwiIG1ldGhvZC5cbiAgICAgICAgLy8gSSB3b25kZXIgaWYgd2VicGFjayBoYXMgc29tZSBwcmFnbWEgdGhhdCBhbGxvd3Mgb3B0aW5nLW91dCBhdCBjZXJ0YWluIHBvaW50c1xuICAgICAgICAvLyBpbiB0aGUgY29kZS5cbiAgICAgICAgY29uc3QgbW9kdWxlTG9hZCA9IHJlcXVpcmUoJ21vZHVsZScpLk1vZHVsZS5fbG9hZDtcbiAgICAgICAgY29uc3Qgbm9kZVJlcXVpcmUgPSAocDogc3RyaW5nKSA9PiBtb2R1bGVMb2FkKHAsIG1vZHVsZSwgZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuc2FuZGJveCA9IHZtLmNyZWF0ZUNvbnRleHQoe1xuICAgICAgICAgICAgQnVmZmVyLCAvLyB0byB1c2Ugc2ltcGxlLXJlc291cmNlLWJ1bmRsZXJcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSwgLy8gYXN5bmMgdGVzdHNcbiAgICAgICAgICAgIHJlcXVpcmU6IG5vZGVSZXF1aXJlIC8vIG1vZHVsZXMgbmVlZCB0byBcInJlcXVpcmVcIlxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgbG9hZChyZXE6IGFwaS5Mb2FkUmVxdWVzdCk6IFByb21pc2U8YXBpLkxvYWRSZXNwb25zZT4ge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnbG9hZCcsIHJlcSk7XG5cbiAgICAgICAgaWYgKCdhc3NlbWJseScgaW4gcmVxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bhc3NlbWJseWAgZmllbGQgaXMgZGVwcmVjYXRlZCBmb3IgXCJsb2FkXCIsIHVzZSBgbmFtZWAsIGB2ZXJzaW9uYCBhbmQgYHRhcmJhbGxgIGluc3RlYWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5pbnN0YWxsRGlyKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbGxEaXIgID0gYXdhaXQgZnMubWtkdGVtcChwYXRoLmpvaW4ob3MudG1wZGlyKCksICdqc2lpLWtlcm5lbC0nKSk7XG4gICAgICAgICAgICBhd2FpdCBmcy5ta2RpcnAocGF0aC5qb2luKHRoaXMuaW5zdGFsbERpciwgJ25vZGVfbW9kdWxlcycpKTtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdjcmVhdGluZyBqc2lpLWtlcm5lbCBtb2R1bGVzIHdvcmtkaXI6JywgdGhpcy5pbnN0YWxsRGlyKTtcblxuICAgICAgICAgICAgcHJvY2Vzcy5vbignZXhpdCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnN0YWxsRGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdyZW1vdmluZyBpbnN0YWxsIGRpcicsIHRoaXMuaW5zdGFsbERpcik7XG4gICAgICAgICAgICAgICAgICAgIGZzLnJlbW92ZVN5bmModGhpcy5pbnN0YWxsRGlyKTsgLy8gY2FuJ3QgdXNlIGFzeW5jIHZlcnNpb24gZHVyaW5nIGV4aXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBrZ25hbWUgPSByZXEubmFtZTtcbiAgICAgICAgY29uc3QgcGtndmVyICA9IHJlcS52ZXJzaW9uO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSBzdWNoIGEgbW9kdWxlXG4gICAgICAgIGNvbnN0IHBhY2thZ2VEaXIgPSBwYXRoLmpvaW4odGhpcy5pbnN0YWxsRGlyLCAnbm9kZV9tb2R1bGVzJywgcGtnbmFtZSk7XG4gICAgICAgIGlmIChhd2FpdCBmcy5wYXRoRXhpc3RzKHBhY2thZ2VEaXIpKSB7XG4gICAgICAgICAgICAvLyBtb2R1bGUgZXhpc3RzLCB2ZXJpZnkgdmVyc2lvblxuICAgICAgICAgICAgY29uc3QgZXBrZyA9IGF3YWl0IGZzLnJlYWRKc29uKHBhdGguam9pbihwYWNrYWdlRGlyLCAncGFja2FnZS5qc29uJykpO1xuICAgICAgICAgICAgaWYgKGVwa2cudmVyc2lvbiAhPT0gcGtndmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdWx0aXBsZSB2ZXJzaW9ucyAke3BrZ3Zlcn0gYW5kICR7ZXBrZy52ZXJzaW9ufSBvZiB0aGUgYFxuICAgICAgICAgICAgICAgICsgYHBhY2thZ2UgJyR7cGtnbmFtZX0nIGNhbm5vdCBiZSBsb2FkZWQgdG9nZXRoZXIgc2luY2UgdGhpcyBpcyB1bnN1cHBvcnRlZCBieSBgXG4gICAgICAgICAgICAgICAgKyBgc29tZSBydW50aW1lIGVudmlyb25tZW50c2ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzYW1lIHZlcnNpb24sIG5vLW9wXG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnbG9vayB1cCBhbHJlYWR5LWxvYWRlZCBhc3NlbWJseScsIHBrZ25hbWUpO1xuICAgICAgICAgICAgY29uc3QgYXNzbSA9IHRoaXMuYXNzZW1ibGllc1twa2duYW1lXTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhc3NlbWJseTogYXNzbS5tZXRhZGF0YS5uYW1lLFxuICAgICAgICAgICAgICAgIHR5cGVzOiBPYmplY3Qua2V5cyhhc3NtLm1ldGFkYXRhLnR5cGVzIHx8wqB7fSkubGVuZ3RoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVudGFyIHRoZSBhcmNoaXZlIHRvIGEgc3RhZ2luZyBkaXJlY3RvcnksIHJlYWQgdGhlIGpzaWkgc3BlYyBmcm9tIGl0XG4gICAgICAgICAgICAvLyBhbmQgdGhlbiBtb3ZlIGl0IHRvIHRoZSBub2RlX21vZHVsZXMgZGlyZWN0b3J5IG9mIHRoZSBrZXJuZWwuXG4gICAgICAgICAgICBjb25zdCBzdGFnaW5nID0gYXdhaXQgZnMubWtkdGVtcChwYXRoLmpvaW4ob3MudG1wZGlyKCksICdqc2lpLWtlcm5lbC1pbnN0YWxsLXN0YWdpbmctJykpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0YXIuZXh0cmFjdCh7IHN0cmljdDogdHJ1ZSwgZmlsZTogcmVxLnRhcmJhbGwsIGN3ZDogc3RhZ2luZyB9KTtcblxuICAgICAgICAgICAgICAgIC8vIHJlYWQgLmpzaWkgbWV0YWRhdGEgZnJvbSB0aGUgcm9vdCBvZiB0aGUgcGFja2FnZVxuICAgICAgICAgICAgICAgIGNvbnN0ICBqc2lpTWV0YWRhdGFGaWxlID0gcGF0aC5qb2luKHN0YWdpbmcsICdwYWNrYWdlJywgc3BlYy5TUEVDX0ZJTEVfTkFNRSk7XG4gICAgICAgICAgICAgICAgaWYgKCEoYXdhaXQgZnMucGF0aEV4aXN0cyhqc2lpTWV0YWRhdGFGaWxlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYWNrYWdlIHRhcmJhbGwgJHtyZXEudGFyYmFsbH0gbXVzdCBoYXZlIGEgZmlsZSBuYW1lZCAke3NwZWMuU1BFQ19GSUxFX05BTUV9IGF0IHRoZSByb290YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFzc21TcGVjID0gYXdhaXQgZnMucmVhZEpzb24oanNpaU1ldGFkYXRhRmlsZSkgYXMgc3BlYy5Bc3NlbWJseTtcblxuICAgICAgICAgICAgICAgIC8vIFwiaW5zdGFsbFwiIHRvIFwibm9kZV9tb2R1bGVzXCIgZGlyZWN0b3J5XG4gICAgICAgICAgICAgICAgYXdhaXQgZnMubW92ZShwYXRoLmpvaW4oc3RhZ2luZywgJ3BhY2thZ2UnKSwgcGFja2FnZURpcik7XG5cbiAgICAgICAgICAgICAgICAvLyBsb2FkIHRoZSBtb2R1bGUgYW5kIGNhcHR1cmUgaXQncyBjbG9zdXJlXG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc3VyZSA9IHRoaXMuX2V4ZWN1dGUoYHJlcXVpcmUoU3RyaW5nLnJhd1xcYCR7cGFja2FnZURpcn1cXGApYCwgcGFja2FnZURpcik7XG4gICAgICAgICAgICAgICAgY29uc3QgYXNzbSA9IG5ldyBBc3NlbWJseShhc3NtU3BlYywgY2xvc3VyZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkQXNzZW1ibHkoYXNzbSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhc3NlbWJseTogYXNzbVNwZWMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZXM6IE9iamVjdC5rZXlzKGFzc21TcGVjLnR5cGVzIHx8IHt9KS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJ3JlbW92aW5nIHN0YWdpbmcgZGlyZWN0b3J5OicsIHN0YWdpbmcpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGZzLnJlbW92ZShzdGFnaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBjcmVhdGUocmVxOiBhcGkuQ3JlYXRlUmVxdWVzdCk6IGFwaS5DcmVhdGVSZXNwb25zZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGUocmVxKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVsKHJlcTogYXBpLkRlbFJlcXVlc3QpOiBhcGkuRGVsUmVzcG9uc2Uge1xuICAgICAgICBjb25zdCB7IG9ianJlZiB9ID0gcmVxO1xuXG4gICAgICAgIHRoaXMuX2RlYnVnKCdkZWwnLCBvYmpyZWYpO1xuICAgICAgICBjb25zdCBvYmogPSB0aGlzLl9maW5kT2JqZWN0KG9ianJlZik7IC8vIG1ha2Ugc3VyZSBvYmplY3QgZXhpc3RzXG4gICAgICAgIGRlbGV0ZSB0aGlzLm9iamVjdHNbb2JqcmVmW1RPS0VOX1JFRl1dO1xuXG4gICAgICAgIGlmIChvYmpbUFJPWFlfUkVGRVJFTlRfUFJPUF0pIHtcbiAgICAgICAgICAgIC8vIERlLXJlZ2lzdGVyIHRoZSBwcm94eSBpZiB0aGlzIHdhcyBhIHByb3h5Li4uXG4gICAgICAgICAgICBkZWxldGUgb2JqW1BST1hZX1JFRkVSRU5UX1BST1BdW1BST1hJRVNfUFJPUF1bb2JqW0ZRTl9QUk9QXV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyB9O1xuICAgIH1cblxuICAgIHB1YmxpYyBzZ2V0KHJlcTogYXBpLlN0YXRpY0dldFJlcXVlc3QpOiBhcGkuR2V0UmVzcG9uc2Uge1xuICAgICAgICBjb25zdCB7IGZxbiwgcHJvcGVydHkgfSA9IHJlcTtcbiAgICAgICAgY29uc3Qgc3ltYm9sID0gYCR7ZnFufS4ke3Byb3BlcnR5fWA7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdzZ2V0Jywgc3ltYm9sKTtcbiAgICAgICAgY29uc3QgdGkgPSB0aGlzLl90eXBlSW5mb0ZvclByb3BlcnR5KGZxbiwgcHJvcGVydHkpO1xuXG4gICAgICAgIGlmICghdGkuc3RhdGljKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByb3BlcnR5ICR7c3ltYm9sfSBpcyBub3Qgc3RhdGljYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm90b3R5cGUgPSB0aGlzLl9maW5kU3ltYm9sKGZxbik7XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9lbnN1cmVTeW5jKGBwcm9wZXJ0eSAke3Byb3BlcnR5fWAsICgpID0+XG4gICAgICAgICAgICB0aGlzLl93cmFwU2FuZGJveENvZGUoKCkgPT4gcHJvdG90eXBlW3Byb3BlcnR5XSkpO1xuXG4gICAgICAgIHRoaXMuX2RlYnVnKCd2YWx1ZTonLCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2Zyb21TYW5kYm94KHZhbHVlLCB0aS50eXBlKTtcbiAgICAgICAgdGhpcy5fZGVidWcoJ3JldCcsIHJldCk7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiByZXQgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3NldChyZXE6IGFwaS5TdGF0aWNTZXRSZXF1ZXN0KTogYXBpLlNldFJlc3BvbnNlIHtcbiAgICAgICAgY29uc3QgeyBmcW4sIHByb3BlcnR5LCB2YWx1ZSB9ID0gcmVxO1xuICAgICAgICBjb25zdCBzeW1ib2wgPSBgJHtmcW59LiR7cHJvcGVydHl9YDtcbiAgICAgICAgdGhpcy5fZGVidWcoJ3NzZXQnLCBzeW1ib2wpO1xuICAgICAgICBjb25zdCB0aSA9IHRoaXMuX3R5cGVJbmZvRm9yUHJvcGVydHkoZnFuLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKCF0aS5zdGF0aWMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJvcGVydHkgJHtzeW1ib2x9IGlzIG5vdCBzdGF0aWNgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aS5pbW11dGFibGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3RhdGljIHByb3BlcnR5ICR7c3ltYm9sfSBpcyByZWFkb25seWApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJvdG90eXBlID0gdGhpcy5fZmluZFN5bWJvbChmcW4pO1xuXG4gICAgICAgIHRoaXMuX2Vuc3VyZVN5bmMoYHByb3BlcnR5ICR7cHJvcGVydHl9YCwgKCkgPT5cbiAgICAgICAgICAgIHRoaXMuX3dyYXBTYW5kYm94Q29kZSgoKSA9PiBwcm90b3R5cGVbcHJvcGVydHldID0gdGhpcy5fdG9TYW5kYm94KHZhbHVlKSkpO1xuXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0KHJlcTogYXBpLkdldFJlcXVlc3QpOiBhcGkuR2V0UmVzcG9uc2Uge1xuICAgICAgICBjb25zdCB7IG9ianJlZiwgcHJvcGVydHkgfSA9IHJlcTtcbiAgICAgICAgdGhpcy5fZGVidWcoJ2dldCcsIG9ianJlZiwgcHJvcGVydHkpO1xuICAgICAgICBjb25zdCBvYmogPSB0aGlzLl9maW5kT2JqZWN0KG9ianJlZik7XG4gICAgICAgIGNvbnN0IGZxbiA9IHRoaXMuX2ZxbkZvck9iamVjdChvYmopO1xuICAgICAgICBjb25zdCB0aSA9IHRoaXMuX3R5cGVJbmZvRm9yUHJvcGVydHkoZnFuLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgLy8gaWYgdGhlIHByb3BlcnR5IGlzIG92ZXJyaWRkZW4gYnkgdGhlIG5hdGl2ZSBjb2RlIGFuZCBcImdldFwiIGlzIGNhbGxlZCBvbiB0aGUgb2JqZWN0LCBpdFxuICAgICAgICAvLyBtZWFucyB0aGF0IHRoZSBuYXRpdmUgY29kZSBpcyB0cnlpbmcgdG8gYWNjZXNzIHRoZSBcInN1cGVyXCIgcHJvcGVydHkuIGluIG9yZGVyIHRvIGVuYWJsZVxuICAgICAgICAvLyB0aGF0LCB3ZSBhY3R1YWxseSBrZWVwIGEgY29weSBvZiB0aGUgb3JpZ2luYWwgcHJvcGVydHkgZGVzY3JpcHRvciB3aGVuIHdlIG92ZXJyaWRlLFxuICAgICAgICAvLyBzbyBgZmluZFByb3BlcnR5VGFyZ2V0YCB3aWxsIHJldHVybiBlaXRoZXIgdGhlIG9yaWdpbmFsIHByb3BlcnR5IG5hbWUgKFwicHJvcGVydHlcIikgb3JcbiAgICAgICAgLy8gdGhlIFwic3VwZXJcIiBwcm9wZXJ0eSBuYW1lIChzb21laGluZyBsaWtlIFwiJGpzaWkkc3VwZXIkPHByb3BlcnR5PiRcIikuXG4gICAgICAgIGNvbnN0IHByb3BlcnR5VG9HZXQgPSB0aGlzLl9maW5kUHJvcGVydHlUYXJnZXQob2JqLCBwcm9wZXJ0eSk7XG5cbiAgICAgICAgLy8gbWFrZSB0aGUgYWN0dWFsIFwiZ2V0XCIsIGFuZCBibG9jayBhbnkgYXN5bmMgY2FsbHMgdGhhdCBtaWdodCBiZSBwZXJmb3JtZWRcbiAgICAgICAgLy8gYnkganNpaSBvdmVycmlkZXMuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZW5zdXJlU3luYyhgcHJvcGVydHkgJyR7b2JqcmVmW1RPS0VOX1JFRl19LiR7cHJvcGVydHlUb0dldH0nYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgpID0+IHRoaXMuX3dyYXBTYW5kYm94Q29kZSgoKSA9PiBvYmpbcHJvcGVydHlUb0dldF0pKTtcbiAgICAgICAgdGhpcy5fZGVidWcoJ3ZhbHVlOicsIHZhbHVlKTtcbiAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5fZnJvbVNhbmRib3godmFsdWUsIHRpLnR5cGUpO1xuICAgICAgICB0aGlzLl9kZWJ1ZygncmV0OicsIHJldCk7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiAgcmV0IH07XG4gICAgfVxuXG4gICAgcHVibGljIHNldChyZXE6IGFwaS5TZXRSZXF1ZXN0KTogYXBpLlNldFJlc3BvbnNlIHtcbiAgICAgICAgY29uc3QgeyBvYmpyZWYsIHByb3BlcnR5LCB2YWx1ZSB9ID0gcmVxO1xuICAgICAgICB0aGlzLl9kZWJ1Zygnc2V0Jywgb2JqcmVmLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICBjb25zdCBvYmogPSB0aGlzLl9maW5kT2JqZWN0KG9ianJlZik7XG5cbiAgICAgICAgY29uc3QgZnFuID0gdGhpcy5fZnFuRm9yT2JqZWN0KG9iaik7XG4gICAgICAgIGNvbnN0IHByb3BJbmZvID0gdGhpcy5fdHlwZUluZm9Gb3JQcm9wZXJ0eShmcW4sIHJlcS5wcm9wZXJ0eSk7XG5cbiAgICAgICAgaWYgKHByb3BJbmZvLmltbXV0YWJsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc2V0IHZhbHVlIG9mIGltbXV0YWJsZSBwcm9wZXJ0eSAke3JlcS5wcm9wZXJ0eX0gdG8gJHtyZXEudmFsdWV9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9wZXJ0eVRvU2V0ID0gdGhpcy5fZmluZFByb3BlcnR5VGFyZ2V0KG9iaiwgcHJvcGVydHkpO1xuXG4gICAgICAgIHRoaXMuX2Vuc3VyZVN5bmMoYHByb3BlcnR5ICcke29ianJlZltUT0tFTl9SRUZdfS4ke3Byb3BlcnR5VG9TZXR9J2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgKCkgPT4gdGhpcy5fd3JhcFNhbmRib3hDb2RlKCgpID0+IG9ialtwcm9wZXJ0eVRvU2V0XSA9IHRoaXMuX3RvU2FuZGJveCh2YWx1ZSkpKTtcblxuICAgICAgICByZXR1cm4geyB9O1xuICAgIH1cblxuICAgIHB1YmxpYyBpbnZva2UocmVxOiBhcGkuSW52b2tlUmVxdWVzdCk6IGFwaS5JbnZva2VSZXNwb25zZSB7XG4gICAgICAgIGNvbnN0IHsgb2JqcmVmLCBtZXRob2QgfSA9IHJlcTtcbiAgICAgICAgY29uc3QgYXJncyA9IHJlcS5hcmdzIHx8IFsgXTtcblxuICAgICAgICB0aGlzLl9kZWJ1ZygnaW52b2tlJywgb2JqcmVmLCBtZXRob2QsIGFyZ3MpO1xuICAgICAgICBjb25zdCB7IHRpLCBvYmosIGZuIH0gPSB0aGlzLl9maW5kSW52b2tlVGFyZ2V0KG9ianJlZiwgbWV0aG9kLCBhcmdzKTtcblxuICAgICAgICAvLyB2ZXJpZnkgdGhpcyBpcyBub3QgYW4gYXN5bmMgbWV0aG9kXG4gICAgICAgIGlmICh0aS5yZXR1cm5zICYmIHRpLnJldHVybnMucHJvbWlzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke21ldGhvZH0gaXMgYW4gYXN5bmMgbWV0aG9kLCB1c2UgXCJiZWdpblwiIGluc3RlYWRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2Vuc3VyZVN5bmMoYG1ldGhvZCAnJHtvYmpyZWZbVE9LRU5fUkVGXX0uJHttZXRob2R9J2AsICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93cmFwU2FuZGJveENvZGUoKCkgPT4gZm4uYXBwbHkob2JqLCB0aGlzLl90b1NhbmRib3hWYWx1ZXMoYXJncykpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0aGlzLl9mcm9tU2FuZGJveChyZXQsIHRpLnJldHVybnMpIH07XG4gICAgfVxuXG4gICAgcHVibGljIHNpbnZva2UocmVxOiBhcGkuU3RhdGljSW52b2tlUmVxdWVzdCk6IGFwaS5JbnZva2VSZXNwb25zZSB7XG4gICAgICAgIGNvbnN0IHsgZnFuLCBtZXRob2QgfSA9IHJlcTtcbiAgICAgICAgY29uc3QgYXJncyA9IHJlcS5hcmdzIHx8IFsgXTtcblxuICAgICAgICB0aGlzLl9kZWJ1Zygnc2ludm9rZScsIGZxbiwgbWV0aG9kLCBhcmdzKTtcblxuICAgICAgICBjb25zdCB0aSA9IHRoaXMuX3R5cGVJbmZvRm9yTWV0aG9kKGZxbiwgbWV0aG9kKTtcblxuICAgICAgICBpZiAoIXRpLnN0YXRpYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Zxbn0uJHttZXRob2R9IGlzIG5vdCBhIHN0YXRpYyBtZXRob2RgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZlcmlmeSB0aGlzIGlzIG5vdCBhbiBhc3luYyBtZXRob2RcbiAgICAgICAgaWYgKHRpLnJldHVybnMgJiYgdGkucmV0dXJucy5wcm9taXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWV0aG9kfSBpcyBhbiBhc3luYyBtZXRob2QsIHVzZSBcImJlZ2luXCIgaW5zdGVhZGApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJvdG90eXBlID0gdGhpcy5fZmluZFN5bWJvbChmcW4pO1xuICAgICAgICBjb25zdCBmbiA9IHByb3RvdHlwZVttZXRob2RdO1xuXG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2Vuc3VyZVN5bmMoYG1ldGhvZCAnJHtmcW59LiR7bWV0aG9kfSdgLCAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFNhbmRib3hDb2RlKCgpID0+IGZuLmFwcGx5KG51bGwsIHRoaXMuX3RvU2FuZGJveFZhbHVlcyhhcmdzKSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9kZWJ1ZygnbWV0aG9kIHJldHVybmVkOicsIHJldCk7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogdGhpcy5fZnJvbVNhbmRib3gocmV0LCB0aS5yZXR1cm5zKSB9O1xuICAgIH1cblxuICAgIHB1YmxpYyBiZWdpbihyZXE6IGFwaS5CZWdpblJlcXVlc3QpOiBhcGkuQmVnaW5SZXNwb25zZSB7XG4gICAgICAgIGNvbnN0IHsgb2JqcmVmLCBtZXRob2QgfSA9IHJlcTtcbiAgICAgICAgY29uc3QgYXJncyA9IHJlcS5hcmdzIHx8IFsgXTtcblxuICAgICAgICB0aGlzLl9kZWJ1ZygnYmVnaW4nLCBvYmpyZWYsIG1ldGhvZCwgYXJncyk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3luY0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGludm9rZSBhc3luYyBtZXRob2QgJyR7cmVxLm9ianJlZltUT0tFTl9SRUZdfS4ke3JlcS5tZXRob2R9JyB3aGlsZSBzeW5jICR7dGhpcy5zeW5jSW5Qcm9ncmVzc30gaXMgYmVpbmcgcHJvY2Vzc2VkYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7IHRpLCBvYmosIGZuIH0gPSB0aGlzLl9maW5kSW52b2tlVGFyZ2V0KG9ianJlZiwgbWV0aG9kLCBhcmdzKTtcblxuICAgICAgICAvLyB2ZXJpZnkgdGhpcyBpcyBpbmRlZWQgYW4gYXN5bmMgbWV0aG9kXG4gICAgICAgIGlmICghdGkucmV0dXJucyB8fCAhdGkucmV0dXJucy5wcm9taXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1ldGhvZCAke21ldGhvZH0gaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXN5bmMgbWV0aG9kYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5fd3JhcFNhbmRib3hDb2RlKCgpID0+IGZuLmFwcGx5KG9iaiwgdGhpcy5fdG9TYW5kYm94VmFsdWVzKGFyZ3MpKSkgYXMgUHJvbWlzZTxhbnk+O1xuXG4gICAgICAgIC8vIHNpbmNlIHdlIGFyZSBwbGFubmluZyB0byByZXNvbHZlIHRoaXMgcHJvbWlzZSBpbiBhIGRpZmZlcmVudCBzY29wZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGhhbmRsZSByZWplY3Rpb25zIGhlcmUgWzFdXG4gICAgICAgIC8vIFsxXTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDA5MjAxNzkvc2hvdWxkLWktcmVmcmFpbi1mcm9tLWhhbmRsaW5nLXByb21pc2UtcmVqZWN0aW9uLWFzeW5jaHJvbm91c2x5LzQwOTIxNTA1XG4gICAgICAgIHByb21pc2UuY2F0Y2goXyA9PiB1bmRlZmluZWQpO1xuXG4gICAgICAgIGNvbnN0IHByaWQgPSB0aGlzLl9tYWtlcHJpZCgpO1xuICAgICAgICB0aGlzLnByb21pc2VzW3ByaWRdID0ge1xuICAgICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICAgIG1ldGhvZDogdGlcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4geyBwcm9taXNlaWQ6IHByaWQgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgZW5kKHJlcTogYXBpLkVuZFJlcXVlc3QpOiBQcm9taXNlPGFwaS5FbmRSZXNwb25zZT4ge1xuICAgICAgICBjb25zdCB7IHByb21pc2VpZCB9ID0gcmVxO1xuXG4gICAgICAgIHRoaXMuX2RlYnVnKCdlbmQnLCBwcm9taXNlaWQpO1xuXG4gICAgICAgIGNvbnN0IHsgcHJvbWlzZSwgbWV0aG9kIH0gPSB0aGlzLnByb21pc2VzW3Byb21pc2VpZF07XG4gICAgICAgIGlmICghcHJvbWlzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBwcm9taXNlIHdpdGggSUQ6ICR7cHJvbWlzZWlkfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHByb21pc2U7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygncHJvbWlzZSByZXN1bHQ6JywgcmVzdWx0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJ3Byb21pc2UgZXJyb3I6JywgZSk7XG4gICAgICAgICAgICB0aHJvdyBtYXBTb3VyY2UoZSwgdGhpcy5zb3VyY2VNYXBzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogdGhpcy5fZnJvbVNhbmRib3gocmVzdWx0LCBtZXRob2QucmV0dXJucykgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY2FsbGJhY2tzKF9yZXE/OiBhcGkuQ2FsbGJhY2tzUmVxdWVzdCk6IGFwaS5DYWxsYmFja3NSZXNwb25zZSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCdjYWxsYmFja3MnKTtcbiAgICAgICAgY29uc3QgcmV0ID0gT2JqZWN0LmtleXModGhpcy5jYnMpLm1hcChjYmlkID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNiID0gdGhpcy5jYnNbY2JpZF07XG4gICAgICAgICAgICB0aGlzLndhaXRpbmdbY2JpZF0gPSBjYjsgLy8gbW92ZSB0byB3YWl0aW5nXG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjazogYXBpLkNhbGxiYWNrID0ge1xuICAgICAgICAgICAgICAgIGNiaWQsXG4gICAgICAgICAgICAgICAgY29va2llOiBjYi5vdmVycmlkZS5jb29raWUsXG4gICAgICAgICAgICAgICAgaW52b2tlOiB7XG4gICAgICAgICAgICAgICAgICAgIG9ianJlZjogY2Iub2JqcmVmLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IGNiLm92ZXJyaWRlLm1ldGhvZCEsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IGNiLmFyZ3NcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gbW92ZSBhbGwgY2FsbGJhY2tzIHRvIHRoZSB3YWl0IHF1ZXVlIGFuZCBjbGVhbiB0aGUgY2FsbGJhY2sgcXVldWUuXG4gICAgICAgIHRoaXMuY2JzID0geyB9O1xuICAgICAgICByZXR1cm4geyBjYWxsYmFja3M6IHJldCB9O1xuICAgIH1cblxuICAgIHB1YmxpYyBjb21wbGV0ZShyZXE6IGFwaS5Db21wbGV0ZVJlcXVlc3QpOiBhcGkuQ29tcGxldGVSZXNwb25zZSB7XG4gICAgICAgIGNvbnN0IHsgY2JpZCwgZXJyLCByZXN1bHQgfSA9IHJlcTtcblxuICAgICAgICB0aGlzLl9kZWJ1ZygnY29tcGxldGUnLCBjYmlkLCBlcnIsIHJlc3VsdCk7XG5cbiAgICAgICAgaWYgKCEoY2JpZCBpbiB0aGlzLndhaXRpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbGxiYWNrICR7Y2JpZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjYiA9IHRoaXMud2FpdGluZ1tjYmlkXTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJ2NvbXBsZXRlZCB3aXRoIGVycm9yOicsIGVycik7XG4gICAgICAgICAgICBjYi5mYWlsKG5ldyBFcnJvcihlcnIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbmRveFJlc3VsdCA9IHRoaXMuX3RvU2FuZGJveChyZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJ2NvbXBsZXRlZCB3aXRoIHJlc3VsdDonLCBzYW5kb3hSZXN1bHQpO1xuICAgICAgICAgICAgY2Iuc3VjY2VlZChzYW5kb3hSZXN1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHRoaXMud2FpdGluZ1tjYmlkXTtcblxuICAgICAgICByZXR1cm4geyBjYmlkIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGFuZ3VhZ2Utc3BlY2lmaWMgbmFtZXMgZm9yIGEganNpaSBtb2R1bGUuXG4gICAgICogQHBhcmFtIGFzc2VtYmx5TmFtZSBUaGUgbmFtZSBvZiB0aGUganNpaSBtb2R1bGUgKGkuZS4ganNpaSRqc2lpX2NhbGN1bGF0b3JfbGliJClcbiAgICAgKi9cbiAgICBwdWJsaWMgbmFtaW5nKHJlcTogYXBpLk5hbWluZ1JlcXVlc3QpOiBhcGkuTmFtaW5nUmVzcG9uc2Uge1xuICAgICAgICBjb25zdCBhc3NlbWJseU5hbWUgPSByZXEuYXNzZW1ibHk7XG5cbiAgICAgICAgdGhpcy5fZGVidWcoJ25hbWluZycsIGFzc2VtYmx5TmFtZSk7XG5cbiAgICAgICAgY29uc3QgYXNzZW1ibHkgPSB0aGlzLl9hc3NlbWJseUZvcihhc3NlbWJseU5hbWUpO1xuICAgICAgICBjb25zdCB0YXJnZXRzID0gYXNzZW1ibHkubWV0YWRhdGEudGFyZ2V0cztcbiAgICAgICAgaWYgKCF0YXJnZXRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgLSBcInRhcmdldHNcIiBmb3IgJHthc3NlbWJseU5hbWV9IGlzIG1pc3NpbmchYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBuYW1pbmc6IHRhcmdldHMgfTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdHMoX3JlcT86IGFwaS5TdGF0c1JlcXVlc3QpOiBhcGkuU3RhdHNSZXNwb25zZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvYmplY3RDb3VudDogT2JqZWN0LmtleXModGhpcy5vYmplY3RzKS5sZW5ndGhcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9hZGRBc3NlbWJseShhc3NtOiBBc3NlbWJseSkge1xuICAgICAgICB0aGlzLmFzc2VtYmxpZXNbYXNzbS5tZXRhZGF0YS5uYW1lXSA9IGFzc207XG5cbiAgICAgICAgLy8gYWRkIHRoZSBfX2pzaWlfXy5mcW4gcHJvcGVydHkgb24gZXZlcnkgY29uc3RydWN0b3IuIHRoaXMgYWxsb3dzXG4gICAgICAgIC8vIHRyYXZlcnNpbmcgYmV0d2VlbiB0aGUgamF2YXNjcmlwdCBhbmQganNpaSB3b3JsZHMgZ2l2ZW4gYW55IG9iamVjdC5cbiAgICAgICAgZm9yIChjb25zdCBmcW4gb2YgT2JqZWN0LmtleXMoYXNzbS5tZXRhZGF0YS50eXBlcyB8fCB7fSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVkZWYgPSBhc3NtLm1ldGFkYXRhLnR5cGVzIVtmcW5dO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlZGVmLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHNwZWMuVHlwZUtpbmQuSW50ZXJmYWNlOlxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gaW50ZXJmYWNlcyBkb24ndCByZWFsbHkgZXhpc3RcbiAgICAgICAgICAgICAgICBjYXNlIHNwZWMuVHlwZUtpbmQuQ2xhc3M6XG4gICAgICAgICAgICAgICAgY2FzZSBzcGVjLlR5cGVLaW5kLkVudW06XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gdGhpcy5fZmluZFN5bWJvbChmcW4pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvci5fX2pzaWlfXyA9IHsgZnFuIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaW5kIHRoZSBqYXZhc2NyaXB0IGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBhIGpzaWkgRlFOLlxuICAgIHByaXZhdGUgX2ZpbmRDdG9yKGZxbjogc3RyaW5nLCBhcmdzOiBhbnlbXSkge1xuICAgICAgICBpZiAoZnFuID09PSBFTVBUWV9PQkpFQ1RfRlFOKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHlwZWluZm8gPSB0aGlzLl90eXBlSW5mb0ZvckZxbihmcW4pO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZWluZm8ua2luZCkge1xuICAgICAgICAgICAgY2FzZSBzcGVjLlR5cGVLaW5kLkNsYXNzOlxuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzVHlwZSA9IHR5cGVpbmZvIGFzIHNwZWMuQ2xhc3NUeXBlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRlTWV0aG9kQXJndW1lbnRzKGNsYXNzVHlwZS5pbml0aWFsaXplciwgYXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRTeW1ib2woZnFuKTtcblxuICAgICAgICAgICAgY2FzZSBzcGVjLlR5cGVLaW5kLkludGVyZmFjZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0O1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBGUU4ga2luZDogJHtmcW59YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwcmVmaXhlZCB3aXRoIF8gdG8gYWxsb3cgY2FsbGluZyB0aGlzIG1ldGhvZCBpbnRlcm5hbGx5IHdpdGhvdXRcbiAgICAvLyBnZXR0aW5nIGl0IHJlY29yZGVkIGZvciB0ZXN0aW5nLlxuICAgIHByaXZhdGUgX2NyZWF0ZShyZXE6IGFwaS5DcmVhdGVSZXF1ZXN0KTogYXBpLkNyZWF0ZVJlc3BvbnNlIHtcbiAgICAgICAgY29uc3QgeyBmcW4sIG92ZXJyaWRlcyB9ID0gcmVxO1xuXG4gICAgICAgIGNvbnN0IHJlcXVlc3RBcmdzID0gcmVxLmFyZ3MgfHwgW107XG5cbiAgICAgICAgY29uc3QgY3RvciA9IHRoaXMuX2ZpbmRDdG9yKGZxbiwgcmVxdWVzdEFyZ3MpO1xuICAgICAgICBjb25zdCBvYmogPSB0aGlzLl93cmFwU2FuZGJveENvZGUoKCkgPT4gbmV3IGN0b3IoLi4udGhpcy5fdG9TYW5kYm94VmFsdWVzKHJlcXVlc3RBcmdzKSkpO1xuICAgICAgICBjb25zdCBvYmpyZWYgPSB0aGlzLl9jcmVhdGVPYmpyZWYob2JqLCBmcW4pO1xuXG4gICAgICAgIC8vIG92ZXJyaWRlczogZm9yIGVhY2ggb25lIG9mIHRoZSBvdmVycmlkZSBtZXRob2QgbmFtZXMsIGluc3RhbGxzIGFcbiAgICAgICAgLy8gbWV0aG9kIG9uIHRoZSBuZXdseSBjcmVhdGVkIG9iamVjdCB3aGljaCByZXByZXNlbnRzIHRoZSByZW1vdGUgXCJyZXZlcnNlIHByb3h5XCIuXG5cbiAgICAgICAgaWYgKG92ZXJyaWRlcykge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJ292ZXJyaWRlcycsIG92ZXJyaWRlcyk7XG5cbiAgICAgICAgICAgIGNvbnN0IG92ZXJyaWRlVHlwZUVycm9yTWVzc2FnZSA9ICdPdmVycmlkZSBjYW4gZWl0aGVyIGJlIFwibWV0aG9kXCIgb3IgXCJwcm9wZXJ0eVwiJztcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZHMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBvdmVycmlkZSBvZiBvdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGUubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZS5wcm9wZXJ0eSkgeyB0aHJvdyBuZXcgRXJyb3Iob3ZlcnJpZGVUeXBlRXJyb3JNZXNzYWdlKTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kcy5oYXMob3ZlcnJpZGUubWV0aG9kKSkgeyB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBvdmVycmlkZSBmb3IgbWV0aG9kICcke292ZXJyaWRlLm1ldGhvZH0nYCk7IH1cblxuICAgICAgICAgICAgICAgICAgICBtZXRob2RzLmFkZChvdmVycmlkZS5tZXRob2QpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgdGhlIG1ldGhvZCBiZWluZyBvdmVycmlkZGVuIGFjdHVhbGx5IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWV0aG9kSW5mbztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZxbiAhPT0gRU1QVFlfT0JKRUNUX0ZRTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3IgaWYgd2UgY2FuIGZpbmQgYSBwcm9wZXJ0eSB3aXRoIHRoaXMgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RyeVR5cGVJbmZvRm9yUHJvcGVydHkoZnFuLCBvdmVycmlkZS5tZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcnlpbmcgdG8gb3ZlcnJpZGUgcHJvcGVydHkgJyR7b3ZlcnJpZGUubWV0aG9kfScgYXMgYSBtZXRob2RgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kSW5mbyA9IHRoaXMuX3RyeVR5cGVJbmZvRm9yTWV0aG9kKGZxbiwgb3ZlcnJpZGUubWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5TWV0aG9kT3ZlcnJpZGUob2JqLCBvYmpyZWYsIG92ZXJyaWRlLCBtZXRob2RJbmZvKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG92ZXJyaWRlLnByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZS5tZXRob2QpIHsgdGhyb3cgbmV3IEVycm9yKG92ZXJyaWRlVHlwZUVycm9yTWVzc2FnZSk7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzKG92ZXJyaWRlLnByb3BlcnR5KSkgeyB0aHJvdyBFcnJvcihgRHVwbGljYXRlIG92ZXJyaWRlIGZvciBwcm9wZXJ0eSAnJHtvdmVycmlkZS5wcm9wZXJ0eX0nYCk7IH1cbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcy5hZGQob3ZlcnJpZGUucHJvcGVydHkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBwcm9wSW5mbzogc3BlYy5Qcm9wZXJ0eSB8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZxbiAhPT0gRU1QVFlfT0JKRUNUX0ZRTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3IgaWYgd2UgY2FuIGZpbmQgYSBtZXRob2Qgd2l0aCB0aGlzIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cnlUeXBlSW5mb0Zvck1ldGhvZChmcW4sIG92ZXJyaWRlLnByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJ5aW5nIHRvIG92ZXJyaWRlIG1ldGhvZCAnJHtvdmVycmlkZS5wcm9wZXJ0eX0nIGFzIGEgcHJvcGVydHlgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcEluZm8gPSB0aGlzLl90cnlUeXBlSW5mb0ZvclByb3BlcnR5KGZxbiwgb3ZlcnJpZGUucHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlQcm9wZXJ0eU92ZXJyaWRlKG9iaiwgb2JqcmVmLCBvdmVycmlkZSwgcHJvcEluZm8pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihvdmVycmlkZVR5cGVFcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmpyZWY7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZ2V0U3VwZXJQcm9wZXJ0eU5hbWUobmFtZTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBgJGpzaWkkc3VwZXIkJHtuYW1lfSRgO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2FwcGx5UHJvcGVydHlPdmVycmlkZShvYmo6IGFueSwgb2JqcmVmOiBhcGkuT2JqUmVmLCBvdmVycmlkZTogYXBpLk92ZXJyaWRlLCBwcm9wSW5mbz86IHNwZWMuUHJvcGVydHkpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IG92ZXJyaWRlLnByb3BlcnR5ITtcblxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgcHJpdmF0ZSBwcm9wZXJ0eSAoaS5lLiBkb2Vzbid0IGhhdmUgYHByb3BJbmZvYCB0aGUgb2JqZWN0IGhhcyBhIGtleSlcbiAgICAgICAgaWYgKCFwcm9wSW5mbyAmJiBwcm9wZXJ0eU5hbWUgaW4gb2JqKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhgU2tpcHBpbmcgb3ZlcnJpZGUgb2YgcHJpdmF0ZSBwcm9wZXJ0eSAke3Byb3BlcnR5TmFtZX1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2RlYnVnKCdhcHBseSBvdmVycmlkZScsIHByb3BlcnR5TmFtZSk7XG5cbiAgICAgICAgLy8gc2F2ZSB0aGUgb2xkIHByb3BlcnR5IHVuZGVyICRqc2lpJHN1cGVyJDxwcm9wPiQgc28gdGhhdCBwcm9wZXJ0eSBvdmVycmlkZXNcbiAgICAgICAgLy8gY2FuIHN0aWxsIGFjY2VzcyBpdCB2aWEgYHN1cGVyLjxwcm9wPmAuXG4gICAgICAgIGNvbnN0IHByZXYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcGVydHlOYW1lKSB8fCB7XG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcHJldkVudW1lcmFibGUgPSBwcmV2LmVudW1lcmFibGU7XG4gICAgICAgIHByZXYuZW51bWVyYWJsZSA9IGZhbHNlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCB0aGlzLl9nZXRTdXBlclByb3BlcnR5TmFtZShwcm9wZXJ0eU5hbWUpLCBwcmV2KTtcblxuICAgICAgICAvLyB3ZSBhZGQgY2FsbGJhY2tzIGZvciBib3RoICdnZXQnIGFuZCAnc2V0JywgZXZlbiBpZiB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gaXMgcmVhZG9ubHkuIHRoaXMgaXMgZmluZSBiZWNhdXNlIGlmIHlvdSB0cnkgdG8gc2V0KCkgYSByZWFkb25seVxuICAgICAgICAvLyBwcm9wZXJ0eSwgaXQgd2lsbCBmYWlsLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHByZXZFbnVtZXJhYmxlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBwcmV2LmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNlbGYuY2FsbGJhY2tIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICAgICAgY29va2llOiBvdmVycmlkZS5jb29raWUsXG4gICAgICAgICAgICAgICAgICAgIGNiaWQ6IHNlbGYuX21ha2VjYmlkKCksXG4gICAgICAgICAgICAgICAgICAgIGdldDogeyBvYmpyZWYsIHByb3BlcnR5OiBwcm9wZXJ0eU5hbWUgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdjYWxsYmFjayByZXR1cm5lZCcsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvU2FuZGJveChyZXN1bHQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLl9kZWJ1ZygndmlydHVhbCBzZXQnLCBvYmpyZWYsIHByb3BlcnR5TmFtZSwgeyBjb29raWU6IG92ZXJyaWRlLmNvb2tpZSB9KTtcbiAgICAgICAgICAgICAgICBzZWxmLmNhbGxiYWNrSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgICAgIGNvb2tpZTogb3ZlcnJpZGUuY29va2llLFxuICAgICAgICAgICAgICAgICAgICBjYmlkOiBzZWxmLl9tYWtlY2JpZCgpLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHsgb2JqcmVmLCBwcm9wZXJ0eTogcHJvcGVydHlOYW1lLCB2YWx1ZTogc2VsZi5fZnJvbVNhbmRib3godmFsdWUpIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfYXBwbHlNZXRob2RPdmVycmlkZShvYmo6IGFueSwgb2JqcmVmOiBhcGkuT2JqUmVmLCBvdmVycmlkZTogYXBpLk92ZXJyaWRlLCBtZXRob2RJbmZvPzogc3BlYy5NZXRob2QpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG1ldGhvZE5hbWUgPSBvdmVycmlkZS5tZXRob2QhO1xuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBwcml2YXRlIG1ldGhvZCAoZG9lc24ndCBoYXZlIG1ldGhvZEluZm8sIGtleSByZXNvbHZlcyBvbiB0aGUgb2JqZWN0KSwgd2VcbiAgICAgICAgLy8gYXJlIGdvaW5nIHRvIHNraXAgdGhlIG92ZXJyaWRlLlxuICAgICAgICBpZiAoIW1ldGhvZEluZm8gJiYgb2JqW21ldGhvZE5hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhgU2tpcHBpbmcgb3ZlcnJpZGUgb2YgcHJpdmF0ZSBtZXRob2QgJHttZXRob2ROYW1lfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm90ZSB0aGF0IHdlIGFyZSBhcHBseWluZyB0aGUgb3ZlcnJpZGUgZXZlbiBpZiB0aGUgbWV0aG9kIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgLy8gb24gdGhlIHR5cGUgc3BlYyBpbiBvcmRlciB0byBhbGxvdyBuYXRpdmUgY29kZSB0byBvdmVycmlkZSBtZXRob2RzIGZyb21cbiAgICAgICAgLy8gaW50ZXJmYWNlcy5cblxuICAgICAgICBpZiAobWV0aG9kSW5mbyAmJiBtZXRob2RJbmZvLnJldHVybnMgJiYgbWV0aG9kSW5mby5yZXR1cm5zLnByb21pc2UpIHtcbiAgICAgICAgICAgIC8vIGFzeW5jIG1ldGhvZCBvdmVycmlkZVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbWV0aG9kTmFtZSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAoLi4ubWV0aG9kQXJnczogYW55W10pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZGVidWcoJ2ludm9rZWQgYXN5bmMgb3ZlcnJpZGUnLCBvdmVycmlkZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBzZWxmLl90b1NhbmRib3hWYWx1ZXMobWV0aG9kQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxhbnk+KChzdWNjZWVkLCBmYWlsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYmlkID0gc2VsZi5fbWFrZWNiaWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2RlYnVnKCdhZGRpbmcgY2FsbGJhY2sgdG8gcXVldWUnLCBjYmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2JzW2NiaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ianJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2NlZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFpbFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzeW5jIG1ldGhvZCBvdmVycmlkZSAobWV0aG9kIGluZm8gaXMgbm90IHJlcXVpcmVkKVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbWV0aG9kTmFtZSwge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAoLi4ubWV0aG9kQXJnczogYW55W10pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc2VsZi5jYWxsYmFja0hhbmRsZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29va2llOiBvdmVycmlkZS5jb29raWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYmlkOiBzZWxmLl9tYWtlY2JpZCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52b2tlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiB0aGlzLl9mcm9tU2FuZGJveChtZXRob2RBcmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvU2FuZGJveChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZmluZEludm9rZVRhcmdldChvYmpyZWY6IGFueSwgbWV0aG9kTmFtZTogc3RyaW5nLCBhcmdzOiBhbnlbXSkge1xuICAgICAgICBjb25zdCBvYmogPSB0aGlzLl9maW5kT2JqZWN0KG9ianJlZik7XG4gICAgICAgIGNvbnN0IGZxbiA9IHRoaXMuX2ZxbkZvck9iamVjdChvYmopO1xuICAgICAgICBjb25zdCB0aSA9IHRoaXMuX3R5cGVJbmZvRm9yTWV0aG9kKGZxbiwgbWV0aG9kTmFtZSk7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRlTWV0aG9kQXJndW1lbnRzKHRpLCBhcmdzKTtcblxuICAgICAgICAvLyBhbHdheXMgZmlyc3QgbG9vayB1cCB0aGUgbWV0aG9kIGluIHRoZSBwcm90b3R5cGUuIHRoaXMgcHJhY3RpY2FsbHkgYnlwYXNzZXNcbiAgICAgICAgLy8gYW55IG1ldGhvZHMgb3ZlcnJpZGRlbiBieSBkZXJpdmVkIGNsYXNzZXMgKHdoaWNoIGFyZSBieSBkZWZpbml0aW9uIG5hdGl2ZVxuICAgICAgICAvLyBtZXRob2RzKS4gdGhpcyBzZXJ2ZXMgdG8gYWxsb3cgbmF0aXZlIGNhbGwgdG8gaW52b2tlIFwic3VwZXIubWV0aG9kKClcIiB3aGVuXG4gICAgICAgIC8vIG92ZXJyaWRpbmcgdGhlIG1ldGhvZC5cbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgdGhlIG1ldGhvZCBvbiB0aGUgcHJvdG90eXBlLCBpdCBjb3VsZCBiZSBhIGxpdGVyYWwgb2JqZWN0XG4gICAgICAgIC8vIHRoYXQgaW1wbGVtZW50cyBhbiBpbnRlcmZhY2UsIHNvIHdlIGxvb2sgaWYgd2UgaGF2ZSB0aGUgbWV0aG9kIG9uIHRoZSBvYmplY3RcbiAgICAgICAgLy8gaXRzZWxmLiBpZiB3ZSBkbywgd2UgaW52b2tlIGl0LlxuICAgICAgICBsZXQgZm4gPSBvYmouY29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICBmbiA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIGlmICghZm4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBmaW5kICR7bWV0aG9kTmFtZX0gb24gb2JqZWN0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdGksIG9iaiwgZm4gfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9mb3JtYXRUeXBlUmVmKHR5cGVSZWY6IHNwZWMuVHlwZVJlZmVyZW5jZSk6IHN0cmluZyB7XG4gICAgICAgIGlmIChzcGVjLmlzQ29sbGVjdGlvblR5cGVSZWZlcmVuY2UodHlwZVJlZikpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHt0eXBlUmVmLmNvbGxlY3Rpb24ua2luZH08JHt0aGlzLl9mb3JtYXRUeXBlUmVmKHR5cGVSZWYuY29sbGVjdGlvbi5lbGVtZW50dHlwZSl9PmA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3BlYy5pc05hbWVkVHlwZVJlZmVyZW5jZSh0eXBlUmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVSZWYuZnFuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNwZWMuaXNQcmltaXRpdmVUeXBlUmVmZXJlbmNlKHR5cGVSZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZVJlZi5wcmltaXRpdmU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3BlYy5pc1VuaW9uVHlwZVJlZmVyZW5jZSh0eXBlUmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVSZWYudW5pb24udHlwZXMubWFwKHQgPT4gdGhpcy5fZm9ybWF0VHlwZVJlZih0KSkuam9pbignIHwgJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdHlwZSByZWZlcmVuY2U6ICR7SlNPTi5zdHJpbmdpZnkodHlwZVJlZil9YCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdmFsaWRhdGVNZXRob2RBcmd1bWVudHMobWV0aG9kOiBzcGVjLk1ldGhvZCB8IHVuZGVmaW5lZCwgYXJnczogYW55W10pIHtcbiAgICAgICAgY29uc3QgcGFyYW1zOiBzcGVjLlBhcmFtZXRlcltdID0gKG1ldGhvZCAmJiBtZXRob2QucGFyYW1ldGVycykgfHwgW107XG5cbiAgICAgICAgLy8gZXJyb3IgaWYgYXJncyA+IHBhcmFtc1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiBwYXJhbXMubGVuZ3RoICYmICEobWV0aG9kICYmIG1ldGhvZC52YXJpYWRpYykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vIG1hbnkgYXJndW1lbnRzIChtZXRob2QgYWNjZXB0cyAke3BhcmFtcy5sZW5ndGh9IHBhcmFtZXRlcnMsIGdvdCAke2FyZ3MubGVuZ3RofSBhcmd1bWVudHMpYCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgcGFyYW0gPSBwYXJhbXNbaV07XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2ldO1xuXG4gICAgICAgICAgICBpZiAocGFyYW0udmFyaWFkaWMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA8PSBpKSB7IHJldHVybjsgfSAvLyBObyB2YXJhcmcgd2FzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgOyBqIDwgcGFyYW1zLmxlbmd0aCA7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zW2pdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCAndW5kZWZpbmVkJyB2YWx1ZSBhdCBpbmRleCAke2ogLSBpfSBvZiB2YXJpYWRpYyBhcmd1bWVudCAnJHtwYXJhbS5uYW1lfScgb2YgdHlwZSAnJHt0aGlzLl9mb3JtYXRUeXBlUmVmKHBhcmFtLnR5cGUpfSdgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXBhcmFtLnR5cGUub3B0aW9uYWwgJiYgYXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgZW5vdWdoIGFyZ3VtZW50cy4gTWlzc2luZyBhcmd1bWVudCBmb3IgdGhlIHJlcXVpcmVkIHBhcmFtZXRlciAnJHtwYXJhbS5uYW1lfScgb2YgdHlwZSAnJHt0aGlzLl9mb3JtYXRUeXBlUmVmKHBhcmFtLnR5cGUpfSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgX2Fzc2VtYmx5Rm9yKGFzc2VtYmx5TmFtZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGFzc2VtYmx5ID0gdGhpcy5hc3NlbWJsaWVzW2Fzc2VtYmx5TmFtZV07XG4gICAgICAgIGlmICghYXNzZW1ibHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYXNzZW1ibHk6ICR7YXNzZW1ibHlOYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3NlbWJseTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9maW5kU3ltYm9sKGZxbjogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IFsgYXNzZW1ibHlOYW1lLCAuLi5wYXJ0cyBdID0gZnFuLnNwbGl0KCcuJyk7XG4gICAgICAgIGNvbnN0IGFzc2VtYmx5ID0gdGhpcy5fYXNzZW1ibHlGb3IoYXNzZW1ibHlOYW1lKTtcblxuICAgICAgICBsZXQgY3VyciA9IGFzc2VtYmx5LmNsb3N1cmU7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyID0gY3VycltuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgc3ltYm9sICR7ZnFufWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2NyZWF0ZU9ianJlZihvYmo6IGFueSwgZnFuOiBzdHJpbmcpOiBhcGkuT2JqUmVmIHtcbiAgICAgICAgY29uc3Qgb2JqaWQgPSB0aGlzLl9ta29iamlkKGZxbik7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIE9CSklEX1BST1AsIHtcbiAgICAgICAgICAgIHZhbHVlOiBvYmppZCxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBGUU5fUFJPUCwge1xuICAgICAgICAgICAgdmFsdWU6IGZxbixcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm9iamVjdHNbb2JqaWRdID0gb2JqO1xuICAgICAgICByZXR1cm4geyBbVE9LRU5fUkVGXTogb2JqaWQgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9maW5kT2JqZWN0KG9ianJlZjogYXBpLk9ialJlZikge1xuICAgICAgICBpZiAodHlwZW9mKG9ianJlZikgIT09ICdvYmplY3QnIHx8ICEoVE9LRU5fUkVGIGluIG9ianJlZikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkIG9iamVjdCByZWZlcmVuY2U6ICR7SlNPTi5zdHJpbmdpZnkob2JqcmVmKX1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9iamlkID0gb2JqcmVmW1RPS0VOX1JFRl07XG4gICAgICAgIHRoaXMuX2RlYnVnKCdmaW5kT2JqZWN0Jywgb2JqaWQpO1xuICAgICAgICBjb25zdCBvYmogPSB0aGlzLm9iamVjdHNbb2JqaWRdO1xuICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgJHtvYmppZH0gbm90IGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBwcml2YXRlIF90eXBlSW5mb0ZvckZxbihmcW46IHN0cmluZyk6IHNwZWMuVHlwZSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBmcW4uc3BsaXQoJy4nKTtcbiAgICAgICAgY29uc3QgbW9kdWxlTmFtZSA9IGNvbXBvbmVudHNbMF07XG5cbiAgICAgICAgY29uc3QgYXNzZW1ibHkgPSB0aGlzLmFzc2VtYmxpZXNbbW9kdWxlTmFtZV07XG4gICAgICAgIGlmICghYXNzZW1ibHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTW9kdWxlICcke21vZHVsZU5hbWV9JyBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHR5cGVzID0gYXNzZW1ibHkubWV0YWRhdGEudHlwZXMgfHzCoHt9O1xuICAgICAgICBjb25zdCBmcW5JbmZvID0gdHlwZXNbZnFuXTtcbiAgICAgICAgaWYgKCFmcW5JbmZvKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGUgJyR7ZnFufScgbm90IGZvdW5kYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnFuSW5mbztcbiAgICB9XG5cbiAgICBwcml2YXRlIF90eXBlSW5mb0Zvck1ldGhvZChmcW46IHN0cmluZywgbWV0aG9kTmFtZTogc3RyaW5nKTogc3BlYy5NZXRob2Qge1xuICAgICAgICBjb25zdCB0aSA9IHRoaXMuX3RyeVR5cGVJbmZvRm9yTWV0aG9kKGZxbiwgbWV0aG9kTmFtZSk7XG4gICAgICAgIGlmICghdGkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2xhc3MgJHtmcW59IGRvZXNuJ3QgaGF2ZSBhIG1ldGhvZCAnJHttZXRob2ROYW1lfSdgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdHJ5VHlwZUluZm9Gb3JNZXRob2QoZnFuOiBzdHJpbmcsIG1ldGhvZE5hbWU6IHN0cmluZyk6IHNwZWMuTWV0aG9kIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgY29uc3QgdHlwZWluZm8gPSB0aGlzLl90eXBlSW5mb0ZvckZxbihmcW4pO1xuXG4gICAgICAgIGNvbnN0IG1ldGhvZHMgPSAodHlwZWluZm8gYXMgKHNwZWMuQ2xhc3NUeXBlIHwgc3BlYy5JbnRlcmZhY2VUeXBlKSkubWV0aG9kcyB8fCBbXTtcbiAgICAgICAgY29uc3QgYmFzZXMgPSBbXG4gICAgICAgICAgICAodHlwZWluZm8gYXMgc3BlYy5DbGFzc1R5cGUpLmJhc2UsXG4gICAgICAgICAgICAuLi4oKHR5cGVpbmZvIGFzIHNwZWMuSW50ZXJmYWNlVHlwZSkuaW50ZXJmYWNlcyB8fCBbXSkgXTtcblxuICAgICAgICBmb3IgKGNvbnN0IG0gb2YgbWV0aG9kcykge1xuICAgICAgICAgICAgaWYgKG0ubmFtZSA9PT0gbWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjdXJzaW9uIHRvIHBhcmVudCB0eXBlIChpZiBleGlzdHMpXG4gICAgICAgIGZvciAoY29uc3QgYmFzZSBvZiBiYXNlcykge1xuICAgICAgICAgICAgaWYgKCFiYXNlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gdGhpcy5fdHJ5VHlwZUluZm9Gb3JNZXRob2QoYmFzZS5mcW4hLCBtZXRob2ROYW1lKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdHJ5VHlwZUluZm9Gb3JQcm9wZXJ0eShmcW46IHN0cmluZywgcHJvcGVydHk6IHN0cmluZyk6IHNwZWMuUHJvcGVydHkgfCB1bmRlZmluZWQge1xuICAgICAgICBpZiAoIWZxbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIFwiZnFuXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlSW5mbyA9IHRoaXMuX3R5cGVJbmZvRm9yRnFuKGZxbik7XG5cbiAgICAgICAgbGV0IHByb3BlcnRpZXM7XG4gICAgICAgIGxldCBiYXNlcztcblxuICAgICAgICBpZiAoc3BlYy5pc0NsYXNzVHlwZSh0eXBlSW5mbykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzVHlwZUluZm8gPSB0eXBlSW5mbyBhcyBzcGVjLkNsYXNzVHlwZTtcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBjbGFzc1R5cGVJbmZvLnByb3BlcnRpZXM7XG4gICAgICAgICAgICBiYXNlcyA9IGNsYXNzVHlwZUluZm8uYmFzZSA/IFsgY2xhc3NUeXBlSW5mby5iYXNlLmZxbiBdIDogW107XG4gICAgICAgIH0gZWxzZSBpZiAoc3BlYy5pc0ludGVyZmFjZVR5cGUodHlwZUluZm8pKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcmZhY2VUeXBlSW5mbyA9IHR5cGVJbmZvIGFzIHNwZWMuSW50ZXJmYWNlVHlwZTtcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBpbnRlcmZhY2VUeXBlSW5mby5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgYmFzZXMgPSAoaW50ZXJmYWNlVHlwZUluZm8uaW50ZXJmYWNlcyB8fCBbXSkubWFwKHggPT4geC5mcW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUeXBlIG9mIGtpbmQgJHt0eXBlSW5mby5raW5kfSBkb2VzIG5vdCBoYXZlIHByb3BlcnRpZXNgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBwcm9wZXJ0aWVzIHx8IFtdKSB7XG4gICAgICAgICAgICBpZiAocC5uYW1lID09PSBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjdXJzZSB0byBwYXJlbnQgdHlwZSAoaWYgZXhpc3RzKVxuICAgICAgICBmb3IgKGNvbnN0IGJhc2VGcW4gb2YgYmFzZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHRoaXMuX3RyeVR5cGVJbmZvRm9yUHJvcGVydHkoYmFzZUZxbiwgcHJvcGVydHkpO1xuICAgICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3R5cGVJbmZvRm9yUHJvcGVydHkoZnFuOiBzdHJpbmcsIHByb3BlcnR5OiBzdHJpbmcpOiBzcGVjLlByb3BlcnR5IHtcbiAgICAgICAgY29uc3QgdHlwZUluZm8gPSB0aGlzLl90cnlUeXBlSW5mb0ZvclByb3BlcnR5KGZxbiwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoIXR5cGVJbmZvKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGUgJHtmcW59IGRvZXNuJ3QgaGF2ZSBhIHByb3BlcnR5ICcke3Byb3BlcnR5fSdgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZUluZm87XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdG9TYW5kYm94KHY6IGFueSk6IGFueSB7XG4gICAgICAgIC8vIHVuZGVmaW5lZFxuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbnVsbCBpcyB0cmVhdGVkIGFzIFwidW5kZWZpbmVkXCIgYmVjYXVzZSBtb3N0IGxhbmd1YWdlcyBkbyBub3QgaGF2ZSB0aGlzIGRpc3RpbmN0aW9uXG4gICAgICAgIC8vIHNlZSBhd3NsYWJzL2F3cy1jZGsjMTU3IGFuZCBhd3NsYWJzL2pzaWkjMjgyXG4gICAgICAgIGlmICh2ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcG9pbnRlclxuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdvYmplY3QnICYmIFRPS0VOX1JFRiBpbiB2KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluZE9iamVjdCh2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRhdGVcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiBUT0tFTl9EQVRFIGluIHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdGb3VuZCBkYXRlOicsIHYpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZbVE9LRU5fREFURV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW51bXNcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiBUT0tFTl9FTlVNIGluIHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdFbnVtOicsIHYpO1xuXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZbVE9LRU5fRU5VTV0gYXMgc3RyaW5nO1xuICAgICAgICAgICAgY29uc3Qgc2VwID0gdmFsdWUubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgICAgIGlmIChzZXAgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNYWxmb3JtZWQgZW51bSB2YWx1ZTogJHt2W1RPS0VOX0VOVU1dfWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0eXBlTmFtZSA9IHZhbHVlLnN1YnN0cigwLCBzZXApO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVOYW1lID0gdmFsdWUuc3Vic3RyKHNlcCArIDEpO1xuXG4gICAgICAgICAgICBjb25zdCBlbnVtVmFsdWUgPSB0aGlzLl9maW5kU3ltYm9sKHR5cGVOYW1lKVt2YWx1ZU5hbWVdO1xuICAgICAgICAgICAgaWYgKGVudW1WYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBlbnVtIG1lbWJlciBuYW1lZCAke3ZhbHVlTmFtZX0gaW4gJHt0eXBlTmFtZX1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fZGVidWcoJ3Jlc29sdmVkIGVudW0gdmFsdWU6JywgZW51bVZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBlbnVtVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcnJheVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIHYubWFwKHggPT4gdGhpcy5fdG9TYW5kYm94KHgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1hcFxuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBvdXQ6IGFueSA9IHsgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh2KSkge1xuICAgICAgICAgICAgICAgIG91dFtrXSA9IHRoaXMuX3RvU2FuZGJveCh2W2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmltaXRpdmVcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZnJvbVNhbmRib3godjogYW55LCB0YXJnZXRUeXBlPzogc3BlYy5UeXBlUmVmZXJlbmNlKTogYW55IHtcbiAgICAgICAgdGhpcy5fZGVidWcoJ2Zyb21TYW5kYm94JywgdiwgdGFyZ2V0VHlwZSk7XG5cbiAgICAgICAgLy8gdW5kZWZpbmVkIGlzIHJldHVybmVkIGFzIG51bGw6IHRydWVcbiAgICAgICAgaWYgKHR5cGVvZih2KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBleGlzdGluZyBvYmplY3RcbiAgICAgICAgY29uc3Qgb2JqaWQgPSB2W09CSklEX1BST1BdO1xuICAgICAgICBpZiAob2JqaWQpIHtcbiAgICAgICAgICAgIC8vIG9iamVjdCBhbHJlYWR5IGhhcyBhbiBvYmppZCwgcmV0dXJuIGl0IGFzIGEgcmVmLlxuICAgICAgICAgICAgdGhpcy5fZGVidWcoJ29ianJlZiBleGlzdHMnLCBvYmppZCk7XG4gICAgICAgICAgICByZXR1cm4geyBbVE9LRU5fUkVGXTogb2JqaWQgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5ldyBvYmplY3RcbiAgICAgICAgaWYgKHR5cGVvZih2KSA9PT0gJ29iamVjdCcgJiYgdi5jb25zdHJ1Y3Rvci5fX2pzaWlfXykge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBqc2lpIG9iamVjdCB3aGljaCB3YXMgY3JlYXRlZCBpbnNpZGUgdGhlIHNhbmRib3ggYW5kIHN0aWxsIGRvZXNuJ3RcbiAgICAgICAgICAgIC8vIGhhdmUgYW4gb2JqZWN0IGlkLCBzbyB3ZSBuZWVkIHRvIGFsbG9jYXRlIG9uZSBmb3IgaXQuXG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnY3JlYXRpbmcgb2JqcmVmIGZvcicsIHYpO1xuICAgICAgICAgICAgY29uc3QgZnFuID0gdGhpcy5fZnFuRm9yT2JqZWN0KHYpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZU9ianJlZih2LCBmcW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIG1ldGhvZC9wcm9wZXJ0eSByZXR1cm5zIGFuIG9iamVjdCBsaXRlcmFsIGFuZCB0aGUgcmV0dXJuIHR5cGVcbiAgICAgICAgLy8gaXMgYSBjbGFzcywgd2UgY3JlYXRlIGEgbmV3IG9iamVjdCBiYXNlZCBvbiB0aGUgZnFuIGFuZCBhc3NpZ24gYWxsIGtleXMuXG4gICAgICAgIC8vIHNvIHRoZSBjbGllbnQgcmVjZWl2ZXMgYSByZWFsIG9iamVjdC5cbiAgICAgICAgaWYgKHR5cGVvZih2KSA9PT0gJ29iamVjdCcgJiYgdGFyZ2V0VHlwZSAmJiBzcGVjLmlzTmFtZWRUeXBlUmVmZXJlbmNlKHRhcmdldFR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnY29hbGVzY2luZyB0bycsIHRhcmdldFR5cGUpO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFdlIFwiY2FjaGVcIiBwcm94eSBpbnN0YW5jZXMgaW4gW1BST1hJRVNfUFJPUF0gc28gd2UgY2FuIHJldHVybiBhblxuICAgICAgICAgICAgICogaWRlbnRpY2FsIG9iamVjdCByZWZlcmVuY2UgdXBvbiBtdWx0aXBsZSBhY2Nlc3NlcyBvZiB0aGUgc2FtZVxuICAgICAgICAgICAgICogb2JqZWN0IGxpdGVyYWwgdW5kZXIgdGhlIHNhbWUgZXhwb3NlZCB0eXBlLiBUaGlzIHJlc3VsdHMgaW4gYVxuICAgICAgICAgICAgICogYmVoYXZpb3IgdGhhdCBpcyBtb3JlIGNvbnNpc3RlbnQgd2l0aCBjbGFzcyBpbnN0YW5jZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHByb3hpZXM6IFByb3hpZXMgPSB2W1BST1hJRVNfUFJPUF0gPSB2W1BST1hJRVNfUFJPUF0gfHwge307XG4gICAgICAgICAgICBpZiAoIXByb3hpZXNbdGFyZ2V0VHlwZS5mcW5dKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IG5ldyBLZXJuZWxQcm94eUhhbmRsZXIodik7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodiwgaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgLy8gX2NyZWF0ZU9ianJlZiB3aWxsIHNldCB0aGUgRlFOX1BST1AgJiBPQkpJRF9QUk9QIG9uIHRoZSBwcm94eS5cbiAgICAgICAgICAgICAgICBwcm94aWVzW3RhcmdldFR5cGUuZnFuXSA9IHsgb2JqUmVmOiB0aGlzLl9jcmVhdGVPYmpyZWYocHJveHksIHRhcmdldFR5cGUuZnFuKSwgaGFuZGxlciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb3hpZXNbdGFyZ2V0VHlwZS5mcW5dLm9ialJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRhdGUgKGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82NDM4MjcvNzM3OTU3KVxuICAgICAgICBpZiAodHlwZW9mKHYpID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJ2RhdGUnLCB2KTtcbiAgICAgICAgICAgIHJldHVybiB7IFtUT0tFTl9EQVRFXTogdi50b0lTT1N0cmluZygpIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcnJheVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJ2FycmF5Jywgdik7XG4gICAgICAgICAgICByZXR1cm4gdi5tYXAoeCA9PiB0aGlzLl9mcm9tU2FuZGJveCh4KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0VHlwZSAmJiBzcGVjLmlzTmFtZWRUeXBlUmVmZXJlbmNlKHRhcmdldFR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wVHlwZSA9IHRoaXMuX3R5cGVJbmZvRm9yRnFuKHRhcmdldFR5cGUuZnFuKTtcblxuICAgICAgICAgICAgLy8gZW51bVxuICAgICAgICAgICAgaWYgKHByb3BUeXBlLmtpbmQgPT09IHNwZWMuVHlwZUtpbmQuRW51bSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdlbnVtJywgdik7XG4gICAgICAgICAgICAgICAgY29uc3QgZnFuID0gcHJvcFR5cGUuZnFuO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVOYW1lID0gdGhpcy5fZmluZFN5bWJvbChmcW4pW3ZdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgW1RPS0VOX0VOVU1dOiBgJHtwcm9wVHlwZS5mcW59LyR7dmFsdWVOYW1lfWAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFwXG4gICAgICAgIGlmICh0eXBlb2YodikgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnbWFwJywgdik7XG4gICAgICAgICAgICBjb25zdCBvdXQ6IGFueSA9IHsgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyh2KSkge1xuICAgICAgICAgICAgICAgIG91dFtrXSA9IHRoaXMuX2Zyb21TYW5kYm94KHZba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByaW1pdGl2ZVxuICAgICAgICB0aGlzLl9kZWJ1ZygncHJpbWl0aXZlJywgdik7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cblxuICAgIHByaXZhdGUgX3RvU2FuZGJveFZhbHVlcyhhcmdzOiBhbnlbXSkge1xuICAgICAgICByZXR1cm4gYXJncy5tYXAodiA9PiB0aGlzLl90b1NhbmRib3godikpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2RlYnVnKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNlRW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgW1xuICAgICAgICAgICAgICAgICdbanNpaS1rZXJuZWxdJyxcbiAgICAgICAgICAgICAgICBhcmdzWzBdLFxuICAgICAgICAgICAgICAgIC4uLmFyZ3Muc2xpY2UoMSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlcyB0aGF0IGBmbmAgaXMgY2FsbGVkIGFuZCBkZWZlbmRzIGFnYWluc3QgYmVnaW5uaW5nIHRvIGludm9rZVxuICAgICAqIGFzeW5jIG1ldGhvZHMgdW50aWwgZm4gZmluaXNoZXMgKHN1Y2Nlc3NmdWxseSBvciBub3QpLlxuICAgICAqL1xuICAgIHByaXZhdGUgX2Vuc3VyZVN5bmM8VD4oZGVzYzogc3RyaW5nLCBmbjogKCkgPT4gVCk6IFQge1xuICAgICAgICB0aGlzLnN5bmNJblByb2dyZXNzID0gZGVzYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuc3luY0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF9maW5kUHJvcGVydHlUYXJnZXQob2JqOiBhbnksIHByb3BlcnR5OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3Qgc3VwZXJQcm9wID0gdGhpcy5fZ2V0U3VwZXJQcm9wZXJ0eU5hbWUocHJvcGVydHkpO1xuICAgICAgICBpZiAoc3VwZXJQcm9wIGluIG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyUHJvcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gdHlwZSBpbmZvcm1hdGlvblxuICAgIC8vXG5cbiAgICBwcml2YXRlIF9mcW5Gb3JPYmplY3Qob2JqOiBhbnkpIHtcbiAgICAgICAgaWYgKEZRTl9QUk9QIGluIG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtGUU5fUFJPUF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9iai5jb25zdHJ1Y3Rvci5fX2pzaWlfXykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBqc2lpIHR5cGUgaW5mbyBmb3Igb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqLmNvbnN0cnVjdG9yLl9fanNpaV9fLmZxbjtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9ta29iamlkKGZxbjogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBgJHtmcW59QCR7dGhpcy5uZXh0aWQrK31gO1xuICAgIH1cblxuICAgIHByaXZhdGUgX21ha2VjYmlkKCkge1xuICAgICAgICByZXR1cm4gYGpzaWk6OmNhbGxiYWNrOjoke3RoaXMubmV4dGlkKyt9YDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9tYWtlcHJpZCgpIHtcbiAgICAgICAgcmV0dXJuIGBqc2lpOjpwcm9taXNlOjoke3RoaXMubmV4dGlkKyt9YDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF93cmFwU2FuZGJveENvZGU8VD4oZm46ICgpID0+IFQpOiBUIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG1hcFNvdXJjZShlcnIsIHRoaXMuc291cmNlTWFwcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBhcmJpdHJhcnkgY29kZSBpbiBhIFZNIHNhbmRib3guXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29kZSAgICAgICBKYXZhU2NyaXB0IGNvZGUgdG8gYmUgZXhlY3V0ZWQgaW4gdGhlIFZNXG4gICAgICogQHBhcmFtIHNhbmRib3ggICAgYSBWTSBjb250ZXh0IHRvIHVzZSBmb3IgcnVubmluZyB0aGUgY29kZVxuICAgICAqIEBwYXJhbSBzb3VyY2VNYXBzIHNvdXJjZSBtYXBzIHRvIGJlIHVzZWQgaW4gY2FzZSBhbiBleGNlcHRpb24gaXMgdGhyb3duXG4gICAgICogQHBhcmFtIGZpbGVuYW1lICAgdGhlIGZpbGUgbmFtZSB0byB1c2UgZm9yIHRoZSBleGVjdXRlZCBjb2RlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgcmVzdWx0IG9mIGV2YWx1YXRpbmcgdGhlIGNvZGVcbiAgICAgKi9cbiAgICBwcml2YXRlIF9leGVjdXRlKGNvZGU6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZykge1xuICAgICAgICBjb25zdCBzY3JpcHQgPSBuZXcgdm0uU2NyaXB0KGNvZGUsIHsgZmlsZW5hbWUgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gc2NyaXB0LnJ1bkluQ29udGV4dCh0aGlzLnNhbmRib3gsIHsgZGlzcGxheUVycm9yczogdHJ1ZSB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBtYXBTb3VyY2UoZXJyLCB0aGlzLnNvdXJjZU1hcHMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5pbnRlcmZhY2UgQ2FsbGJhY2sge1xuICAgIG9ianJlZjogYXBpLk9ialJlZjtcbiAgICBvdmVycmlkZTogYXBpLk92ZXJyaWRlO1xuICAgIGFyZ3M6IGFueVtdO1xuXG4gICAgLy8gY29tcGxldGlvbiBjYWxsYmFja3NcbiAgICBzdWNjZWVkOiAoLi4uYXJnczogYW55W10pID0+IGFueTtcbiAgICBmYWlsOiAoLi4uYXJnczogYW55W10pID0+IGFueTtcbn1cblxuaW50ZXJmYWNlIEFzeW5jSW52b2NhdGlvbiB7XG4gICAgbWV0aG9kOiBzcGVjLk1ldGhvZFxuICAgIHByb21pc2U6IFByb21pc2U8YW55PlxufVxuXG5jbGFzcyBBc3NlbWJseSB7XG4gICAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IG1ldGFkYXRhOiBzcGVjLkFzc2VtYmx5LFxuICAgICAgICAgICAgICAgIHB1YmxpYyByZWFkb25seSBjbG9zdXJlOiBhbnkpIHtcbiAgICB9XG59XG5cbi8qKlxuICogQXBwbGllcyBzb3VyY2UgbWFwcyB0byBhbiBlcnJvcidzIHN0YWNrIHRyYWNlIGFuZCByZXR1cm5zIHRoZSBtYXBwZWQgZXJyb3IsXG4gKiBhbmQgc3RpdGNoZXMgc3RhY2sgdHJhY2UgZWxlbWVudHMgdG8gYWRhcHQgdGhlIGNvbnRleHQgdG8gdGhlIGN1cnJlbnQgdHJhY2UuXG4gKlxuICogQHBhcmFtIGVyciAgICAgICAgaXMgdGhlIGVycm9yIHRvIGJlIG1hcHBlZFxuICogQHBhcmFtIHNvdXJjZU1hcHMgdGhlIHNvdXJjZSBtYXBzIHRvIGJlIHVzZWRcbiAqXG4gKiBAcmV0dXJucyB0aGUgbWFwcGVkIGVycm9yXG4gKi9cbmZ1bmN0aW9uIG1hcFNvdXJjZShlcnI6IEVycm9yLCBzb3VyY2VNYXBzOiB7IFthc3NtOiBzdHJpbmddOiBTb3VyY2VNYXBDb25zdW1lciB9KTogRXJyb3Ige1xuICAgIGlmICghZXJyLnN0YWNrKSB7IHJldHVybiBlcnI7IH1cbiAgICBjb25zdCBvbGRGcmFtZXMgPSBlcnIuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgY29uc3Qgb2JqID0geyBzdGFjazogJycgfTtcbiAgICBjb25zdCBwcmV2aW91c0xpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICAgIHRyeSB7XG4gICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGVyci5zdGFjay5zcGxpdChcIlxcblwiKS5sZW5ndGg7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKG9iaiwgbWFwU291cmNlKTtcbiAgICAgICAgY29uc3QgcmVhbEZyYW1lcyA9IG9iai5zdGFjay5zcGxpdCgnXFxuJykuc2xpY2UoMSk7XG4gICAgICAgIGNvbnN0IHRvcEZyYW1lID0gcmVhbEZyYW1lc1swXS5zdWJzdHJpbmcoMCwgcmVhbEZyYW1lc1swXS5pbmRleE9mKCcgKCcpKTtcbiAgICAgICAgZXJyLnN0YWNrID0gW1xuICAgICAgICAgICAgLi4ub2xkRnJhbWVzLnNsaWNlKDAsIG9sZEZyYW1lcy5maW5kSW5kZXgoZnJhbWUgPT4gZnJhbWUuc3RhcnRzV2l0aCh0b3BGcmFtZSkpKS5tYXAoYXBwbHlNYXBzKSxcbiAgICAgICAgICAgIC4uLnJlYWxGcmFtZXNcbiAgICAgICAgXS5qb2luKFwiXFxuXCIpO1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IHByZXZpb3VzTGltaXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlNYXBzKGZyYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBtYXBwYWJsZSA9IC9eKFxccyphdFxccysuKylcXChqc2lpXFwvKC4rKVxcLmpzOihcXGQrKTooXFxkKylcXCkkLztcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IG1hcHBhYmxlLmV4ZWMoZnJhbWUpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpIHsgcmV0dXJuIGZyYW1lOyB9XG4gICAgICAgIGNvbnN0IGFzc20gPSBtYXRjaGVzWzJdO1xuICAgICAgICBpZiAoIShhc3NtIGluIHNvdXJjZU1hcHMpKSB7IHJldHVybiBmcmFtZTsgfVxuICAgICAgICBjb25zdCBwcmVmaXggPSBtYXRjaGVzWzFdO1xuICAgICAgICBjb25zdCBsaW5lID0gcGFyc2VJbnQobWF0Y2hlc1szXSwgMTApO1xuICAgICAgICBjb25zdCBjb2x1bW4gPSBwYXJzZUludChtYXRjaGVzWzRdLCAxMCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZU1hcCA9IHNvdXJjZU1hcHNbYXNzbV07XG4gICAgICAgIGNvbnN0IHBvcyA9IHNvdXJjZU1hcC5vcmlnaW5hbFBvc2l0aW9uRm9yKHsgbGluZSwgY29sdW1uIH0pO1xuICAgICAgICBpZiAocG9zLnNvdXJjZSAhPSBudWxsICYmIHBvcy5saW5lICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHBvcy5zb3VyY2UucmVwbGFjZSgvXndlYnBhY2s6XFwvXFwvLywgYCR7YXNzbX1gKTtcbiAgICAgICAgICAgIHJldHVybiBgJHtwcmVmaXh9KCR7c291cmNlfToke3Bvcy5saW5lfToke3Bvcy5jb2x1bW4gfHwgMH0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxufVxuXG50eXBlIE9iamVjdEtleSA9IHN0cmluZyB8IG51bWJlciB8IHN5bWJvbDtcbi8qKlxuICogQSBQcm94eSBoYW5kbGVyIGNsYXNzIHRvIHN1cHBvcnQgbXV0YXRpb24gb2YgdGhlIHJldHVybmVkIG9iamVjdCBsaXRlcmFscywgYXNcbiAqIHRoZXkgbWF5IFwiZW1ib2R5XCIgc2V2ZXJhbCBkaWZmZXJlbnQgaW50ZXJmYWNlcy4gVGhlIGhhbmRsZXIgaXMgaW4gcGFydGljdWxhclxuICogcmVzcG9uc2libGUgdG8gbWFrZSBzdXJlIHRoZSBgYEZRTl9QUk9QYGAgYW5kIGBgT0JKSURfUFJPUGBgIGRvIG5vdCBnZXQgc2V0XG4gKiBvbiB0aGUgYGByZWZlcmVudGBgIG9iamVjdCwgZm9yIHRoaXMgd291bGQgY2F1c2Ugc3Vic2VxdWVudCBhY2Nlc3NlcyB0b1xuICogcG9zc2libHkgcmV0dXJuIGluY29ycmVjdCBvYmplY3QgcmVmZXJlbmNlcy5cbiAqL1xuY2xhc3MgS2VybmVsUHJveHlIYW5kbGVyIGltcGxlbWVudHMgUHJveHlIYW5kbGVyPGFueT4ge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgb3duUHJvcGVydGllczogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHJlZmVyZW50IHRoZSBcInJlYWxcIiB2YWx1ZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHJlZmVyZW50OiBhbnkpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogUHJveHktcHJvcGVydGllcyBtdXN0IGV4aXN0IGFzIG5vbi1jb25maWd1cmFibGUgJiB3cml0YWJsZSBvbiB0aGVcbiAgICAgICAgICogcmVmZXJlbnQsIG90aGVyd2lzZSB0aGUgUHJveHkgd2lsbCBub3QgYWxsb3cgcmV0dXJuaW5nIGBgdHJ1ZWBgIGluXG4gICAgICAgICAqIHJlc3BvbnNlIHRvIGBgZGVmaW5lUHJvcGVydHlgYC5cbiAgICAgICAgICovXG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBbRlFOX1BST1AsIE9CSklEX1BST1BdKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVmZXJlbnQsIHByb3AsIHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGRlZmluZVByb3BlcnR5KHRhcmdldDogYW55LCBwcm9wZXJ0eTogT2JqZWN0S2V5LCBhdHRyaWJ1dGVzOiBQcm9wZXJ0eURlc2NyaXB0b3IpOiBib29sZWFuIHtcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgICBjYXNlIEZRTl9QUk9QOlxuICAgICAgICBjYXNlIE9CSklEX1BST1A6XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMub3duUHJvcGVydGllcywgcHJvcGVydHksIGF0dHJpYnV0ZXMpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBkZWxldGVQcm9wZXJ0eSh0YXJnZXQ6IGFueSwgcHJvcGVydHk6IE9iamVjdEtleSk6IGJvb2xlYW4ge1xuICAgICAgICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgICAgIGNhc2UgRlFOX1BST1A6XG4gICAgICAgIGNhc2UgT0JKSURfUFJPUDpcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm93blByb3BlcnRpZXNbcHJvcGVydHldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0W3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldDogYW55LCBwcm9wZXJ0eTogT2JqZWN0S2V5KTogUHJvcGVydHlEZXNjcmlwdG9yIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgICBjYXNlIEZRTl9QUk9QOlxuICAgICAgICBjYXNlIE9CSklEX1BST1A6XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLm93blByb3BlcnRpZXMsIHByb3BlcnR5KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldCh0YXJnZXQ6IGFueSwgcHJvcGVydHk6IE9iamVjdEtleSk6IGFueSB7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgLy8gTWFnaWNhbCBwcm9wZXJ0eSBmb3IgdGhlIHByb3h5LCBzbyB3ZSBjYW4gdGVsbCBpdCdzIG9uZS4uLlxuICAgICAgICBjYXNlIFBST1hZX1JFRkVSRU5UX1BST1A6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZlcmVudDtcbiAgICAgICAgY2FzZSBGUU5fUFJPUDpcbiAgICAgICAgY2FzZSBPQkpJRF9QUk9QOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3duUHJvcGVydGllc1twcm9wZXJ0eV07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBzZXQodGFyZ2V0OiBhbnksIHByb3BlcnR5OiBPYmplY3RLZXksIHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgICAgICBjYXNlIEZRTl9QUk9QOlxuICAgICAgICBjYXNlIE9CSklEX1BST1A6XG4gICAgICAgICAgICB0aGlzLm93blByb3BlcnRpZXNbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRhcmdldFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaGFzKHRhcmdldDogYW55LCBwcm9wZXJ0eTogT2JqZWN0S2V5KTogYm9vbGVhbiB7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgY2FzZSBGUU5fUFJPUDpcbiAgICAgICAgY2FzZSBPQkpJRF9QUk9QOlxuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMub3duUHJvcGVydGllcztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgb3duS2V5cyh0YXJnZXQ6IGFueSk6IE9iamVjdEtleVtdIHtcbiAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpLmNvbmNhdChSZWZsZWN0Lm93bktleXModGhpcy5vd25Qcm9wZXJ0aWVzKSk7XG4gICAgfVxufVxuXG50eXBlIFByb3hpZXMgPSB7IFtmcW46IHN0cmluZ106IFByb3h5UmVmZXJlbmNlIH07XG5pbnRlcmZhY2UgUHJveHlSZWZlcmVuY2Uge1xuICAgIG9ialJlZjogYXBpLk9ialJlZjtcbiAgICBoYW5kbGVyOiBLZXJuZWxQcm94eUhhbmRsZXI7XG59XG4iXX0=